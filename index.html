<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>B Cellars — Vineyard Map (v11)</title>

  <!-- Mapbox GL JS -->
  <script src="https://api.tiles.mapbox.com/mapbox-gl-js/v3.6.0/mapbox-gl.js"></script>
  <link href="https://api.tiles.mapbox.com/mapbox-gl-js/v3.6.0/mapbox-gl.css" rel="stylesheet" />
  <!-- Turf.js -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <style>
    :root{
      --bg:#0b0c10; --panel:#111318; --text:#eef2f7; --muted:#6b7280;
      --border:#e5e7eb; --brand:#cc4346;
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0; overflow:hidden; overscroll-behavior:none; background:var(--bg); color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";}
    .app{height:100vh; display:grid; grid-template-columns:360px 1fr; grid-template-rows:100%;}
    .app.sidebar-collapsed{grid-template-columns:0 1fr;}
    #map{position:relative; height:100%; width:100%;}

    /* Sidebar (white theme) */
    .sidebar{background:#ffffff; color:#111318; border-right:1px solid var(--border); display:flex; flex-direction:column; gap:14px; padding:18px; overflow:auto;}
    .brand{display:flex; align-items:center; justify-content:space-between; gap:10px;}
    .brand h1{font-size:20px; margin:0; color:#111318;}
    .controls{display:flex; gap:8px; flex-wrap:nowrap; align-items:center; justify-content:flex-start;}
    .btn{padding:10px 14px; border-radius:12px; border:1px solid var(--border); background:#f9fafb; color:#111318; font-size:14px; cursor:pointer; text-decoration:none; display:inline-flex; align-items:center; gap:6px;}
    .btn.primary{ background:var(--brand); color:#ffffff; border-color:var(--brand); }
    .btn.secondary{ background:#ffffff; border-color:var(--border); }

    .search{display:flex; gap:8px; width:100%;}
    .search input{flex:1; padding:10px 12px; border-radius:12px; border:1px solid #e5e7eb; background:#ffffff; color:#111318;}

    .count{font-size:12px; color:var(--muted);}
    .list{display:flex; flex-direction:column; gap:8px; padding-bottom:10px;}
    .item{border:1px solid var(--brand); background:#ffffff; border-radius:14px; padding:12px 14px; cursor:pointer; text-align:left;}
    .item.active{outline:2px solid #111318;}
    .item .name{font-weight:700; font-size:16px; color:#111318;}
    .item .meta{font-size:12px; color:var(--muted); margin-top:2px;}
    .item .actions{margin-top:8px; display:flex; gap:8px; flex-wrap:wrap;}

    .sidebar-toggle-fab{position:absolute; top:12px; left:12px; z-index:5; display:none;}
    .sidebar-toggle-fab .btn{box-shadow:0 6px 20px rgba(0,0,0,.35);}

    .mapboxgl-popup{font:14px/1.25 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}
    .mapboxgl-popup-content{border-radius:12px; padding:10px 12px; background:#0f1219; color:#eef2f7; border:1px solid #273049; text-align:left;}

    @media (max-width:900px){.app{grid-template-columns:1fr;} .sidebar{display:none;} }
  </style>
</head>
<body>
  <div class="app">
    <aside class="sidebar" aria-label="Vineyard navigation" id="sidebar">
      <div class="brand">
        <h1>Vineyard Sources</h1>
      </div>
      <div class="controls">
          <button id="fit-all" class="btn" title="Zoom to all vineyards">Fit all</button>
          <button id="collapse" class="btn secondary" title="Hide/show sidebar">Collapse</button>
          
        </div>
      </div>
      <div class="search">
        <input id="filter" type="search" placeholder="Filter… (Name, SubAVA, Facts)" aria-label="Filter vineyards" />
      </div>
      <div class="count" id="count" aria-live="polite">—</div>
      <div class="list" id="list" role="list"></div>
      <div class="count" style="margin-top:auto;">Click polygons or use the list.</div>
    </aside>

    <div id="map" role="region" aria-label="Map of vineyard locations">
      <div class="sidebar-toggle-fab" id="sidebar-fab">
        <button class="btn" id="expand-sidebar" title="Show sidebar">Show sidebar</button>
      </div>
    </div>
  </div>

  <script>
    // ===== Config =====
    const CONFIG = {
      accessToken: 'pk.eyJ1IjoiZ3JhaGFtLWJjZWxsYXJzIiwiYSI6ImNsbmR1dWZiZjA3OXoyeWxpNTR4Z29wMjMifQ.Dw9ZRaGWdJkYUrFpML7XTw',
      styleUrl: 'mapbox://styles/graham-bcellars/clogch2tt004201oi8i3jgyjy',
      vector: {
        url: 'mapbox://graham-bcellars.clnunbjdd0gcp2nn54qh84xr9-17y6g',
        sourceLayer: 'Vineyard-Sources' // confirm exact name in Studio → Inspect
      },
      dataset: {
        id: 'clnunbjdd0gcp2nn54qh84xr9',
        username: 'graham-bcellars'
      },
      defaultCenter: [-122.37, 38.45],
      defaultZoom: 10
    };

    mapboxgl.accessToken = CONFIG.accessToken;
    const map = new mapboxgl.Map({
      container: 'map',
      style: CONFIG.styleUrl,
      center: CONFIG.defaultCenter,
      zoom: CONFIG.defaultZoom,
      pitch: 0,
      bearing: 0,
      cooperativeGestures: true,
      attributionControl: true
    });
    map.addControl(new mapboxgl.NavigationControl({showCompass:true}), 'top-right');
    map.addControl(new mapboxgl.FullscreenControl(), 'top-right');

    // ===== State =====
    const listEl = document.getElementById('list');
    const countEl = document.getElementById('count');
    const filterEl = document.getElementById('filter');
    const fitAllBtn = document.getElementById('fit-all');
    const collapseBtn = document.getElementById('collapse');
    const appEl = document.querySelector('.app');
    const fab = document.getElementById('sidebar-fab');
    const expandBtn = document.getElementById('expand-sidebar');
    const popup = new mapboxgl.Popup({ closeButton: true, closeOnClick: true });

    // Index by Name → { center:[lng,lat], bbox:[minX,minY,maxX,maxY], props:{...} }
    let nameIndex = {};
    // Sorted list of names currently visible (after filter)
    let namesList = [];

    // ===== Utilities =====
    function getName(props){ return (props && (props.Name ?? props.name ?? props.NAME)) ? String(props.Name ?? props.name ?? props.NAME) : null; }
    function mergeBbox(acc, b){
      if (!acc) return b.slice();
      return [Math.min(acc[0], b[0]), Math.min(acc[1], b[1]), Math.max(acc[2], b[2]), Math.max(acc[3], b[3])];
    }
    function buildIndexFromDataset(fc){
      const accum = new Map(); // name -> { sum:[lng,lat], n:int, bbox:[...], props }
      for (const f of fc.features || []){
        const nm = getName(f.properties);
        if (!nm) continue;
        let b;
        try { b = turf.bbox(f); } catch(e){ continue; }
        let c;
        try { c = turf.centroid(f).geometry.coordinates; } catch(e){ continue; }
        if (!accum.has(nm)){
          // Choose first non-empty props for SubAVA/Facts/URL
          const p = f.properties || {};
          accum.set(nm, {
            sum:[c[0], c[1]], n:1, bbox:b.slice(),
            props:{
              Name: nm,
              SubAVA: p.SubAVA || p.AVA || '',
              Facts: p.Facts || p.facts || '',
              URL: p.URL || p.url || ''
            }
          });
        } else {
          const rec = accum.get(nm);
          rec.sum[0]+=c[0]; rec.sum[1]+=c[1]; rec.n+=1;
          rec.bbox = mergeBbox(rec.bbox, b);
          // keep existing props
        }
      }
      nameIndex = {};
      for (const [nm, rec] of accum.entries()){
        const center = [rec.sum[0]/rec.n, rec.sum[1]/rec.n];
        nameIndex[nm] = { center, bbox: rec.bbox, props: rec.props };
      }
    }
    function namesAsFeatureCollection(names){
      return {
        type:'FeatureCollection',
        features: names.map(nm => ({
          type:'Feature',
          properties: nameIndex[nm].props,
          geometry: { type:'Point', coordinates: nameIndex[nm].center }
        }))
      };
    }
    function buildList(names){
      listEl.innerHTML = '';
      for (const nm of names){
        const p = nameIndex[nm].props;
        const li = document.createElement('button');
        li.className = 'item';
        li.type = 'button';
        li.dataset.id = nm;
        li.innerHTML = `
          <div class="name">${p.Name}</div>
          <div class="meta">${p.SubAVA || ''}</div>
          <div class="actions">
            <span class="btn primary" aria-hidden="true">Fly To Vineyard</span>
            ${p.URL ? `<a class="btn" href="${p.URL}" target="_blank" rel="noopener" onclick="event.stopPropagation()">Learn more</a>` : ''}
          </div>`;
        li.addEventListener('click', () => selectByName(nm));
        listEl.appendChild(li);
      }
      countEl.textContent = `${names.length} vineyard${names.length===1?'':'s'}`;
    }
    function highlightInList(name){
      document.querySelectorAll('.item').forEach(el => el.classList.toggle('active', el.dataset.id === name));
      const active = document.querySelector('.item.active'); if (active) active.scrollIntoView({block:'nearest', behavior:'smooth'});
    }
    function showPopup(name){
      const rec = nameIndex[name]; if (!rec) return;
      const p = rec.props, lngLat = rec.center;
      const html = `
        <div>
          <div style="font-weight:700; margin-bottom:4px;">${p.Name || 'Vineyard'}</div>
          ${p.SubAVA ? `<div style="font-size:12px; opacity:.8;">${p.SubAVA}</div>` : ''}
          ${p.Facts ? `<div style="margin-top:6px;">${p.Facts}</div>` : ''}
          ${p.URL ? `<div style="margin-top:8px;"><a class="btn" href="${p.URL}" target="_blank" rel="noopener">Learn more →</a></div>` : ''}
        </div>`;
      popup.setLngLat(lngLat).setHTML(html).addTo(map);
    }
    function ensureHighlightLayers(){
      if (!map.getLayer('vineyard-selected-fill')) {
        map.addLayer({
          id: 'vineyard-selected-fill',
          type: 'fill',
          source: 'vineyard-polygons',
          'source-layer': 'Vineyard-Sources',
          paint: { 'fill-color': '#ffffff', 'fill-opacity': 0.25 },
          filter: ['==', ['get', 'Name'], '___none___']
        }, 'vineyard-outline');
      }
      if (!map.getLayer('vineyard-selected-line')) {
        map.addLayer({
          id: 'vineyard-selected-line',
          type: 'line',
          source: 'vineyard-polygons',
          'source-layer': 'Vineyard-Sources',
          paint: { 'line-color': '#ffffff', 'line-width': 2.5 },
          filter: ['==', ['get', 'Name'], '___none___']
        });
      }
    }
    function setHighlight(name){
      ensureHighlightLayers();
      map.setFilter('vineyard-selected-fill', ['==', ['get','Name'], name]);
      map.setFilter('vineyard-selected-line', ['==', ['get','Name'], name]);
    }
    function cinematicFly(bbox, center){
      const currentZoom = map.getZoom();
      const marginFactor = 0.15;
      const doFit = () => {
        if (bbox) {
          // Expand bbox by 15% margin on all sides
          const dx = (bbox[2] - bbox[0]) * marginFactor;
          const dy = (bbox[3] - bbox[1]) * marginFactor;
          const expanded = [bbox[0]-dx, bbox[1]-dy, bbox[2]+dx, bbox[3]+dy];
          map.fitBounds([[expanded[0], expanded[1]], [expanded[2], expanded[3]]], { padding: 0, maxZoom: 17 });
          setTimeout(() => map.easeTo({ pitch: 40, duration: 300 }), 50);
        } else if (center) {
          map.flyTo({ center, zoom: 17, pitch: 40, speed: 0.9, curve: 1.4, essential: true });
        }
      };
      if (currentZoom > 15.5) {
        map.easeTo({ zoom: Math.min(currentZoom, 12.5), duration: 250 });
        setTimeout(doFit, 260);
      } else {
        doFit();
      }
    }
    function selectByName(name){
      const rec = nameIndex[name];
      if (!rec) return;
      setHighlight(name);
      const b = rec.bbox;
      cinematicFly(b, rec.center);
      showPopup(name);
      highlightInList(name);
      history.replaceState(null, '', `#id=${encodeURIComponent(name)}`);
    }
    function fitAll(){
      const names = namesList.length ? namesList : Object.keys(nameIndex);
      if (!names.length) return;
      const coords = names.map(nm => nameIndex[nm].center);
      const b = coords.reduce((bounds, c) => bounds.extend(c), new mapboxgl.LngLatBounds(coords[0], coords[0]));
      map.fitBounds(b, { padding: 50 });
    }
    function debounce(fn, ms=200){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; }
    const doFilter = debounce((q)=>{
      const term = q.trim().toLowerCase();
      const names = Object.keys(nameIndex).filter(nm => {
        const p = nameIndex[nm].props;
        return [p.Name, p.SubAVA, p.Facts].some(v => (v||'').toLowerCase().includes(term));
      }).sort((a,b)=> a.localeCompare(b));
      namesList = names;
      buildList(namesList);
    }, 160);

    // ===== Data plumbing =====
    async function fetchDataset() {
      const url = `https://api.mapbox.com/datasets/v1/${CONFIG.dataset.username}/${CONFIG.dataset.id}/features?access_token=${encodeURIComponent(mapboxgl.accessToken)}`;
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) throw new Error('Dataset fetch failed: ' + res.status);
      const fc = await res.json();
      if (!fc || !fc.features) throw new Error('No features in dataset.');
      return fc;
    }

    async function rebuildFromDataset(){
      const fc = await fetchDataset();
      buildIndexFromDataset(fc);
      // Build sidebar list (sorted, deduped)
      namesList = Object.keys(nameIndex).sort((a,b)=> a.localeCompare(b));
      buildList(namesList);

      // Labels from grouped centers (no markers)
      const labelsFC = namesAsFeatureCollection(namesList);
      if (map.getSource('vineyard-points')) map.removeSource('vineyard-points');
      if (map.getLayer('vineyard-labels')) map.removeLayer('vineyard-labels');
      map.addSource('vineyard-points', { type:'geojson', data: labelsFC });
      map.addLayer({
        id:'vineyard-labels',
        type:'symbol',
        source:'vineyard-points',
        minzoom: 12,
        layout:{ 'text-field':['get','Name'], 'text-size':12, 'text-offset':[0,1.1], 'text-anchor':'top', 'text-allow-overlap': true },
        paint:{ 'text-color':'#eef2f7', 'text-halo-color':'#0b0c10', 'text-halo-width':1.2 }
      });
    }

    // ===== Init =====
    map.on('load', async () => {
      // Polygons from tileset
      map.addSource('vineyard-polygons', { type:'vector', url: CONFIG.vector.url });
      map.addLayer({ id:'vineyard-fill', type:'fill', source:'vineyard-polygons', 'source-layer': 'Vineyard-Sources', paint:{ 'fill-color':'#c64b4b', 'fill-opacity':0.35 } });
      map.addLayer({ id:'vineyard-outline', type:'line', source:'vineyard-polygons', 'source-layer': 'Vineyard-Sources', paint:{ 'line-color':'#c64b4b', 'line-width':1.2 } });

      try {
        await rebuildFromDataset();
        fitAll();
      } catch (e) {
        console.error(e);
        alert('Failed to load dataset features. Check token or dataset permissions.');
      }

      // Polygon click -> select by Name (with fallbacks on key casing)
      ['vineyard-fill','vineyard-outline'].forEach(layer => {
        map.on('click', layer, (e)=>{
          const f = e.features && e.features[0]; if (!f) return;
          const name = getName(f.properties);
          if (name) { selectByName(name); }
        });
        map.on('mouseenter', layer, () => map.getCanvas().style.cursor='pointer');
        map.on('mouseleave', layer, () => map.getCanvas().style.cursor='');
      });
      
      // Deep link
      const m = location.hash.match(/id=([^&]+)/); if (m) setTimeout(()=>selectByName(decodeURIComponent(m[1])), 300);
    });

    // ===== UI events =====
    fitAllBtn.addEventListener('click', fitAll);
    filterEl.addEventListener('input', (e)=> doFilter(e.target.value));

    // Sidebar collapse / expand (with floating reopen button)
    let collapsed = false;
    function setCollapsed(val){
      collapsed = !!val;
      appEl.classList.toggle('sidebar-collapsed', collapsed);
      document.getElementById('sidebar').setAttribute('aria-hidden', collapsed ? 'true' : 'false');
      if (collapsed && window.innerWidth > 900) { fab.style.display = 'block'; } else { fab.style.display = 'none'; }
      setTimeout(()=>map.resize(), 60);
    }
    collapseBtn.addEventListener('click', () => setCollapsed(!collapsed));
    expandBtn.addEventListener('click', () => setCollapsed(false));
    window.addEventListener('resize', () => { if (window.innerWidth <= 900) fab.style.display='none'; else if (collapsed) fab.style.display='block'; });

    // Keyboard: S to toggle sidebar, / to focus filter
    document.addEventListener('keydown', (e)=>{
      if (e.key === '/' && document.activeElement !== filterEl) { e.preventDefault(); filterEl.focus(); }
      else if (e.key.toLowerCase() === 's' && window.innerWidth > 900) { setCollapsed(!collapsed); }
      else if (e.key === 'Escape') { popup.remove(); history.replaceState(null, '', location.pathname); const a=document.querySelector('.item.active'); if(a) a.classList.remove('active'); }
    });
  </script>
</body>
</html>
      <div class="sidebar-toggle-fab" id="sidebar-fab">
        <button class="btn" id="expand-sidebar" title="Show sidebar">Show sidebar</button>
      </div>
    </div>
  </div>

  <script>
    // ===== Config =====
    const CONFIG = {
      accessToken: 'pk.eyJ1IjoiZ3JhaGFtLWJjZWxsYXJzIiwiYSI6ImNsbmR1dWZiZjA3OXoyeWxpNTR4Z29wMjMifQ.Dw9ZRaGWdJkYUrFpML7XTw',
      styleUrl: 'mapbox://styles/graham-bcellars/clogch2tt004201oi8i3jgyjy',
      vector: {
        url: 'mapbox://graham-bcellars.clnunbjdd0gcp2nn54qh84xr9-17y6g',
        sourceLayer: 'vineyard-sources' // confirm exact name in Studio → Inspect
      },
      dataset: {
        id: 'clnunbjdd0gcp2nn54qh84xr9',
        username: 'graham-bcellars'
      },
      defaultCenter: [-122.37, 38.45],
      defaultZoom: 10
    };

    mapboxgl.accessToken = CONFIG.accessToken;
    const map = new mapboxgl.Map({
      container: 'map',
      style: CONFIG.styleUrl,
      center: CONFIG.defaultCenter,
      zoom: CONFIG.defaultZoom,
      pitch: 0,
      bearing: 0,
      cooperativeGestures: true,
      attributionControl: true
    });
    map.addControl(new mapboxgl.NavigationControl({showCompass:true}), 'top-right');
    map.addControl(new mapboxgl.FullscreenControl(), 'top-right');

    // ===== State =====
    const listEl = document.getElementById('list');
    const countEl = document.getElementById('count');
    const filterEl = document.getElementById('filter');
    const fitAllBtn = document.getElementById('fit-all');
    const collapseBtn = document.getElementById('collapse');
    const appEl = document.querySelector('.app');
    const fab = document.getElementById('sidebar-fab');
    const expandBtn = document.getElementById('expand-sidebar');
    const popup = new mapboxgl.Popup({ closeButton: true, closeOnClick: true });

    // Index by Name → { center:[lng,lat], bbox:[minX,minY,maxX,maxY], props:{...} }
    let nameIndex = {};
    // Sorted list of names currently visible (after filter)
    let namesList = [];

    // ===== Utilities =====
    function getName(props){ return (props && (props.Name ?? props.name ?? props.NAME)) ? String(props.Name ?? props.name ?? props.NAME) : null; }
    function mergeBbox(acc, b){
      if (!acc) return b.slice();
      return [Math.min(acc[0], b[0]), Math.min(acc[1], b[1]), Math.max(acc[2], b[2]), Math.max(acc[3], b[3])];
    }
    function buildIndexFromDataset(fc){
      const accum = new Map(); // name -> { sum:[lng,lat], n:int, bbox:[...], props }
      for (const f of fc.features || []){
        const nm = getName(f.properties);
        if (!nm) continue;
        let b;
        try { b = turf.bbox(f); } catch(e){ continue; }
        let c;
        try { c = turf.centroid(f).geometry.coordinates; } catch(e){ continue; }
        if (!accum.has(nm)){
          // Choose first non-empty props for SubAVA/Facts/URL
          const p = f.properties || {};
          accum.set(nm, {
            sum:[c[0], c[1]], n:1, bbox:b.slice(),
            props:{
              Name: nm,
              SubAVA: p.SubAVA || p.AVA || '',
              Facts: p.Facts || p.facts || '',
              URL: p.URL || p.url || ''
            }
          });
        } else {
          const rec = accum.get(nm);
          rec.sum[0]+=c[0]; rec.sum[1]+=c[1]; rec.n+=1;
          rec.bbox = mergeBbox(rec.bbox, b);
          // keep existing props
        }
      }
      nameIndex = {};
      for (const [nm, rec] of accum.entries()){
        const center = [rec.sum[0]/rec.n, rec.sum[1]/rec.n];
        nameIndex[nm] = { center, bbox: rec.bbox, props: rec.props };
      }
    }
    function namesAsFeatureCollection(names){
      return {
        type:'FeatureCollection',
        features: names.map(nm => ({
          type:'Feature',
          properties: nameIndex[nm].props,
          geometry: { type:'Point', coordinates: nameIndex[nm].center }
        }))
      };
    }
    function buildList(names){
      listEl.innerHTML = '';
      for (const nm of names){
        const p = nameIndex[nm].props;
        const li = document.createElement('button');
        li.className = 'item';
        li.type = 'button';
        li.dataset.id = nm;
        li.innerHTML = `
          <div class="name">${p.Name}</div>
          <div class="meta">${p.SubAVA || ''}</div>
          <div class="actions">
            <span class="btn primary" aria-hidden="true">Fly To Vineyard</span>
            ${p.URL ? `<a class="btn" href="${p.URL}" target="_blank" rel="noopener" onclick="event.stopPropagation()">Learn more</a>` : ''}
          </div>`;
        li.addEventListener('click', () => selectByName(nm));
        listEl.appendChild(li);
      }
      countEl.textContent = `${names.length} vineyard${names.length===1?'':'s'}`;
    }
    function highlightInList(name){
      document.querySelectorAll('.item').forEach(el => el.classList.toggle('active', el.dataset.id === name));
      const active = document.querySelector('.item.active'); if (active) active.scrollIntoView({block:'nearest', behavior:'smooth'});
    }
    function showPopup(name){
      const rec = nameIndex[name]; if (!rec) return;
      const p = rec.props, lngLat = rec.center;
      const html = `
        <div>
          <div style="font-weight:700; margin-bottom:4px;">${p.Name || 'Vineyard'}</div>
          ${p.SubAVA ? `<div style="font-size:12px; opacity:.8;">${p.SubAVA}</div>` : ''}
          ${p.Facts ? `<div style="margin-top:6px;">${p.Facts}</div>` : ''}
          ${p.URL ? `<div style="margin-top:8px;"><a class="btn" href="${p.URL}" target="_blank" rel="noopener">Learn more →</a></div>` : ''}
        </div>`;
      popup.setLngLat(lngLat).setHTML(html).addTo(map);
    }
    function ensureHighlightLayers(){
      if (!map.getLayer('vineyard-selected-fill')) {
        map.addLayer({
          id: 'vineyard-selected-fill',
          type: 'fill',
          source: 'vineyard-polygons',
          'source-layer': CONFIG.vector.sourceLayer,
          paint: { 'fill-color': '#ffffff', 'fill-opacity': 0.25 },
          filter: ['==', ['get', 'Name'], '___none___']
        }, 'vineyard-outline');
      }
      if (!map.getLayer('vineyard-selected-line')) {
        map.addLayer({
          id: 'vineyard-selected-line',
          type: 'line',
          source: 'vineyard-polygons',
          'source-layer': CONFIG.vector.sourceLayer,
          paint: { 'line-color': '#ffffff', 'line-width': 2.5 },
          filter: ['==', ['get', 'Name'], '___none___']
        });
      }
    }
    function setHighlight(name){
      ensureHighlightLayers();
      map.setFilter('vineyard-selected-fill', ['==', ['get','Name'], name]);
      map.setFilter('vineyard-selected-line', ['==', ['get','Name'], name]);
    }
    function cinematicFly(bbox, center){
      // If already zoomed in, zoom out a bit first for context, then fly back in
      const currentZoom = map.getZoom();
      const stepOutZoom = 12.5;
      const doFit = () => {
        if (bbox) {
          map.fitBounds([[bbox[0], bbox[1]], [bbox[2], bbox[3]]], { padding: 60, maxZoom: 18.5 });
          setTimeout(() => map.easeTo({ center: center || map.getCenter(), zoom: 18.5, pitch: 45, duration: 400 }), 120);
        } else if (center) {
          map.flyTo({ center, zoom: 18.5, pitch: 45, speed: 0.9, curve: 1.4, essential: true });
        }
      };
      if (currentZoom > 15.5) {
        map.easeTo({ zoom: Math.min(currentZoom, stepOutZoom), duration: 250 });
        setTimeout(doFit, 260);
      } else {
        doFit();
      }
    }
    function selectByName(name){
      const rec = nameIndex[name];
      if (!rec) return;
      setHighlight(name);
      const b = rec.bbox;
      cinematicFly(b, rec.center);
      showPopup(name);
      highlightInList(name);
      history.replaceState(null, '', `#id=${encodeURIComponent(name)}`);
    }
    function fitAll(){
      const names = namesList.length ? namesList : Object.keys(nameIndex);
      if (!names.length) return;
      const coords = names.map(nm => nameIndex[nm].center);
      const b = coords.reduce((bounds, c) => bounds.extend(c), new mapboxgl.LngLatBounds(coords[0], coords[0]));
      map.fitBounds(b, { padding: 50 });
    }
    function debounce(fn, ms=200){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; }
    const doFilter = debounce((q)=>{
      const term = q.trim().toLowerCase();
      const names = Object.keys(nameIndex).filter(nm => {
        const p = nameIndex[nm].props;
        return [p.Name, p.SubAVA, p.Facts].some(v => (v||'').toLowerCase().includes(term));
      }).sort((a,b)=> a.localeCompare(b));
      namesList = names;
      buildList(namesList);
    }, 160);

    // ===== Data plumbing =====
    async function fetchDataset() {
      const url = `https://api.mapbox.com/datasets/v1/${CONFIG.dataset.username}/${CONFIG.dataset.id}/features?access_token=${encodeURIComponent(mapboxgl.accessToken)}`;
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) throw new Error('Dataset fetch failed: ' + res.status);
      const fc = await res.json();
      if (!fc || !fc.features) throw new Error('No features in dataset.');
      return fc;
    }

    async function rebuildFromDataset(){
      const fc = await fetchDataset();
      buildIndexFromDataset(fc);
      // Build sidebar list (sorted, deduped)
      namesList = Object.keys(nameIndex).sort((a,b)=> a.localeCompare(b));
      buildList(namesList);

      // Labels from grouped centers (no markers)
      const labelsFC = namesAsFeatureCollection(namesList);
      if (map.getSource('vineyard-points')) map.removeSource('vineyard-points');
      if (map.getLayer('vineyard-labels')) map.removeLayer('vineyard-labels');
      map.addSource('vineyard-points', { type:'geojson', data: labelsFC });
      map.addLayer({
        id:'vineyard-labels',
        type:'symbol',
        source:'vineyard-points',
        minzoom: 12,
        layout:{ 'text-field':['get','Name'], 'text-size':12, 'text-offset':[0,1.1], 'text-anchor':'top', 'text-allow-overlap': true },
        paint:{ 'text-color':'#eef2f7', 'text-halo-color':'#0b0c10', 'text-halo-width':1.2 }
      });
    }

    // ===== Init =====
    map.on('load', async () => {
      // Polygons from tileset
      map.addSource('vineyard-polygons', { type:'vector', url: CONFIG.vector.url });
      map.addLayer({ id:'vineyard-fill', type:'fill', source:'vineyard-polygons', 'source-layer': CONFIG.vector.sourceLayer, paint:{ 'fill-color':'#c64b4b', 'fill-opacity':0.35 } });
      map.addLayer({ id:'vineyard-outline', type:'line', source:'vineyard-polygons', 'source-layer': CONFIG.vector.sourceLayer, paint:{ 'line-color':'#c64b4b', 'line-width':1.2 } });

      try {
        await rebuildFromDataset();
        fitAll();
      } catch (e) {
        console.error(e);
        alert('Failed to load dataset features. Check token or dataset permissions.');
      }

      // Polygon click -> select by Name (with fallbacks on key casing)
      ['vineyard-fill','vineyard-outline'].forEach(layer => {
        map.on('click', layer, (e)=>{
          const f = e.features && e.features[0]; if (!f) return;
          const name = getName(f.properties);
          if (name) { selectByName(name); }
        });
        map.on('mouseenter', layer, () => map.getCanvas().style.cursor='pointer');
        map.on('mouseleave', layer, () => map.getCanvas().style.cursor='');
      });
      
      // Deep link
      const m = location.hash.match(/id=([^&]+)/); if (m) setTimeout(()=>selectByName(decodeURIComponent(m[1])), 300);
    });

    // ===== UI events =====
    fitAllBtn.addEventListener('click', fitAll);
    filterEl.addEventListener('input', (e)=> doFilter(e.target.value));

    // Sidebar collapse / expand (with floating reopen button)
    let collapsed = false;
    function setCollapsed(val){
      collapsed = !!val;
      appEl.classList.toggle('sidebar-collapsed', collapsed);
      document.getElementById('sidebar').setAttribute('aria-hidden', collapsed ? 'true' : 'false');
      if (collapsed && window.innerWidth > 900) { fab.style.display = 'block'; } else { fab.style.display = 'none'; }
      setTimeout(()=>map.resize(), 60);
    }
    collapseBtn.addEventListener('click', () => setCollapsed(!collapsed));
    expandBtn.addEventListener('click', () => setCollapsed(false));
    window.addEventListener('resize', () => { if (window.innerWidth <= 900) fab.style.display='none'; else if (collapsed) fab.style.display='block'; });

    // Keyboard: S to toggle sidebar, / to focus filter
    document.addEventListener('keydown', (e)=>{
      if (e.key === '/' && document.activeElement !== filterEl) { e.preventDefault(); filterEl.focus(); }
      else if (e.key.toLowerCase() === 's' && window.innerWidth > 900) { setCollapsed(!collapsed); }
      else if (e.key === 'Escape') { popup.remove(); history.replaceState(null, '', location.pathname); const a=document.querySelector('.item.active'); if(a) a.classList.remove('active'); }
    });
  </script>
</body>
</html>
      <div class="sidebar-toggle-fab" id="sidebar-fab">
        <button class="btn" id="expand-sidebar" title="Show sidebar">Show sidebar</button>
      </div>
    </div>
  </div>

  <script>
    // ===== Config =====
    const CONFIG = {
      accessToken: 'pk.eyJ1IjoiZ3JhaGFtLWJjZWxsYXJzIiwiYSI6ImNsbmR1dWZiZjA3OXoyeWxpNTR4Z29wMjMifQ.Dw9ZRaGWdJkYUrFpML7XTw',
      styleUrl: 'mapbox://styles/graham-bcellars/clogch2tt004201oi8i3jgyjy',
      vector: {
        url: 'mapbox://graham-bcellars.clnunbjdd0gcp2nn54qh84xr9-17y6g',
        sourceLayer: 'vineyard-sources' // confirm exact name in Studio → Inspect
      },
      dataset: {
        id: 'clnunbjdd0gcp2nn54qh84xr9',
        username: 'graham-bcellars'
      },
      defaultCenter: [-122.37, 38.45],
      defaultZoom: 10
    };

    mapboxgl.accessToken = CONFIG.accessToken;
    const map = new mapboxgl.Map({
      container: 'map',
      style: CONFIG.styleUrl,
      center: CONFIG.defaultCenter,
      zoom: CONFIG.defaultZoom,
      pitch: 0,
      bearing: 0,
      cooperativeGestures: true,
      attributionControl: true
    });
    map.addControl(new mapboxgl.NavigationControl({showCompass:true}), 'top-right');
    map.addControl(new mapboxgl.FullscreenControl(), 'top-right');

    // ===== State =====
    const listEl = document.getElementById('list');
    const countEl = document.getElementById('count');
    const filterEl = document.getElementById('filter');
    const fitAllBtn = document.getElementById('fit-all');
    const collapseBtn = document.getElementById('collapse');
    const appEl = document.querySelector('.app');
    const fab = document.getElementById('sidebar-fab');
    const expandBtn = document.getElementById('expand-sidebar');
    const popup = new mapboxgl.Popup({ closeButton: true, closeOnClick: true });

    // Index by Name → { center:[lng,lat], bbox:[minX,minY,maxX,maxY], props:{...} }
    let nameIndex = {};
    // Sorted list of names currently visible (after filter)
    let namesList = [];

    // ===== Utilities =====
    function getName(props){ return (props && (props.Name ?? props.name ?? props.NAME)) ? String(props.Name ?? props.name ?? props.NAME) : null; }
    function mergeBbox(acc, b){
      if (!acc) return b.slice();
      return [Math.min(acc[0], b[0]), Math.min(acc[1], b[1]), Math.max(acc[2], b[2]), Math.max(acc[3], b[3])];
    }
    function buildIndexFromDataset(fc){
      const accum = new Map(); // name -> { sum:[lng,lat], n:int, bbox:[...], props }
      for (const f of fc.features || []){
        const nm = getName(f.properties);
        if (!nm) continue;
        let b;
        try { b = turf.bbox(f); } catch(e){ continue; }
        let c;
        try { c = turf.centroid(f).geometry.coordinates; } catch(e){ continue; }
        if (!accum.has(nm)){
          // Choose first non-empty props for SubAVA/Facts/URL
          const p = f.properties || {};
          accum.set(nm, {
            sum:[c[0], c[1]], n:1, bbox:b.slice(),
            props:{
              Name: nm,
              SubAVA: p.SubAVA || p.AVA || '',
              Facts: p.Facts || p.facts || '',
              URL: p.URL || p.url || ''
            }
          });
        } else {
          const rec = accum.get(nm);
          rec.sum[0]+=c[0]; rec.sum[1]+=c[1]; rec.n+=1;
          rec.bbox = mergeBbox(rec.bbox, b);
          // keep existing props
        }
      }
      nameIndex = {};
      for (const [nm, rec] of accum.entries()){
        const center = [rec.sum[0]/rec.n, rec.sum[1]/rec.n];
        nameIndex[nm] = { center, bbox: rec.bbox, props: rec.props };
      }
    }
    function namesAsFeatureCollection(names){
      return {
        type:'FeatureCollection',
        features: names.map(nm => ({
          type:'Feature',
          properties: nameIndex[nm].props,
          geometry: { type:'Point', coordinates: nameIndex[nm].center }
        }))
      };
    }
    function buildList(names){
      listEl.innerHTML = '';
      for (const nm of names){
        const p = nameIndex[nm].props;
        const li = document.createElement('button');
        li.className = 'item';
        li.type = 'button';
        li.dataset.id = nm;
        li.innerHTML = `
          <div class="name">${p.Name}</div>
          <div class="meta">${p.SubAVA || ''}</div>
          <div class="actions">
            <span class="btn primary" aria-hidden="true">Fly To Vineyard</span>
            ${p.URL ? `<a class="btn" href="${p.URL}" target="_blank" rel="noopener" onclick="event.stopPropagation()">Learn more</a>` : ''}
          </div>`;
        li.addEventListener('click', () => selectByName(nm));
        listEl.appendChild(li);
      }
      countEl.textContent = `${names.length} vineyard${names.length===1?'':'s'}`;
    }
    function highlightInList(name){
      document.querySelectorAll('.item').forEach(el => el.classList.toggle('active', el.dataset.id === name));
      const active = document.querySelector('.item.active'); if (active) active.scrollIntoView({block:'nearest', behavior:'smooth'});
    }
    function showPopup(name){
      const rec = nameIndex[name]; if (!rec) return;
      const p = rec.props, lngLat = rec.center;
      const html = `
        <div>
          <div style="font-weight:700; margin-bottom:4px;">${p.Name || 'Vineyard'}</div>
          ${p.SubAVA ? `<div style="font-size:12px; opacity:.8;">${p.SubAVA}</div>` : ''}
          ${p.Facts ? `<div style="margin-top:6px;">${p.Facts}</div>` : ''}
          ${p.URL ? `<div style="margin-top:8px;"><a class="btn" href="${p.URL}" target="_blank" rel="noopener">Learn more →</a></div>` : ''}
        </div>`;
      popup.setLngLat(lngLat).setHTML(html).addTo(map);
    }
    function ensureHighlightLayers(){
      if (!map.getLayer('vineyard-selected-fill')) {
        map.addLayer({
          id: 'vineyard-selected-fill',
          type: 'fill',
          source: 'vineyard-polygons',
          'source-layer': CONFIG.vector.sourceLayer,
          paint: { 'fill-color': '#ffffff', 'fill-opacity': 0.25 },
          filter: ['==', ['get', 'Name'], '___none___']
        }, 'vineyard-outline');
      }
      if (!map.getLayer('vineyard-selected-line')) {
        map.addLayer({
          id: 'vineyard-selected-line',
          type: 'line',
          source: 'vineyard-polygons',
          'source-layer': CONFIG.vector.sourceLayer,
          paint: { 'line-color': '#ffffff', 'line-width': 2.5 },
          filter: ['==', ['get', 'Name'], '___none___']
        });
      }
    }
    function setHighlight(name){
      ensureHighlightLayers();
      map.setFilter('vineyard-selected-fill', ['==', ['get','Name'], name]);
      map.setFilter('vineyard-selected-line', ['==', ['get','Name'], name]);
    }
    function selectByName(name){
      const rec = nameIndex[name];
      if (!rec) return;
      setHighlight(name);
      // Fit to dataset bbox (robust, doesn't rely on rendered tiles)
      const b = rec.bbox;
      if (b) {
        map.fitBounds([[b[0], b[1]], [b[2], b[3]]], { padding: 50, maxZoom: 17.5 });
        setTimeout(() => map.easeTo({ pitch: 60, duration: 300 }), 50);
      } else {
        map.flyTo({ center: rec.center, zoom: 17.5, pitch: 60, speed: 0.8, curve: 1.6, essential: true });
      }
      showPopup(name);
      highlightInList(name);
      history.replaceState(null, '', `#id=${encodeURIComponent(name)}`);
    }
    function fitAll(){
      const names = namesList.length ? namesList : Object.keys(nameIndex);
      if (!names.length) return;
      const coords = names.map(nm => nameIndex[nm].center);
      const b = coords.reduce((bounds, c) => bounds.extend(c), new mapboxgl.LngLatBounds(coords[0], coords[0]));
      map.fitBounds(b, { padding: 50 });
    }
    function debounce(fn, ms=200){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; }
    const doFilter = debounce((q)=>{
      const term = q.trim().toLowerCase();
      const names = Object.keys(nameIndex).filter(nm => {
        const p = nameIndex[nm].props;
        return [p.Name, p.SubAVA, p.Facts].some(v => (v||'').toLowerCase().includes(term));
      }).sort((a,b)=> a.localeCompare(b));
      namesList = names;
      buildList(namesList);
    }, 160);

    // ===== Data plumbing =====
    async function fetchDataset() {
      const url = `https://api.mapbox.com/datasets/v1/${CONFIG.dataset.username}/${CONFIG.dataset.id}/features?access_token=${encodeURIComponent(mapboxgl.accessToken)}`;
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) throw new Error('Dataset fetch failed: ' + res.status);
      const fc = await res.json();
      if (!fc || !fc.features) throw new Error('No features in dataset.');
      return fc;
    }

    async function rebuildFromDataset(){
      const fc = await fetchDataset();
      buildIndexFromDataset(fc);
      // Build sidebar list (sorted, deduped)
      namesList = Object.keys(nameIndex).sort((a,b)=> a.localeCompare(b));
      buildList(namesList);

      // Labels from grouped centers (no markers)
      const labelsFC = namesAsFeatureCollection(namesList);
      if (map.getSource('vineyard-points')) map.removeSource('vineyard-points');
      if (map.getLayer('vineyard-labels')) map.removeLayer('vineyard-labels');
      map.addSource('vineyard-points', { type:'geojson', data: labelsFC });
      map.addLayer({
        id:'vineyard-labels',
        type:'symbol',
        source:'vineyard-points',
        minzoom: 12,
        layout:{ 'text-field':['get','Name'], 'text-size':12, 'text-offset':[0,1.1], 'text-anchor':'top', 'text-allow-overlap': true },
        paint:{ 'text-color':'#eef2f7', 'text-halo-color':'#0b0c10', 'text-halo-width':1.2 }
      });
    }

    // ===== Init =====
    map.on('load', async () => {
      // Polygons from tileset
      map.addSource('vineyard-polygons', { type:'vector', url: CONFIG.vector.url });
      map.addLayer({ id:'vineyard-fill', type:'fill', source:'vineyard-polygons', 'source-layer': CONFIG.vector.sourceLayer, paint:{ 'fill-color':'#c64b4b', 'fill-opacity':0.35 } });
      map.addLayer({ id:'vineyard-outline', type:'line', source:'vineyard-polygons', 'source-layer': CONFIG.vector.sourceLayer, paint:{ 'line-color':'#c64b4b', 'line-width':1.2 } });

      try {
        await rebuildFromDataset();
        fitAll();
      } catch (e) {
        console.error(e);
        alert('Failed to load dataset features. Check token or dataset permissions.');
      }

      // Polygon click -> select by Name (with fallbacks on key casing)
      map.on('click','vineyard-fill', (e)=>{
        const f = e.features && e.features[0]; if (!f) return;
        const name = getName(f.properties);
        if (name) { selectByName(name); }
      });
      map.on('mouseenter','vineyard-fill', () => map.getCanvas().style.cursor='pointer');
      map.on('mouseleave','vineyard-fill', () => map.getCanvas().style.cursor='');

      // Deep link
      const m = location.hash.match(/id=([^&]+)/); if (m) setTimeout(()=>selectByName(decodeURIComponent(m[1])), 300);
    });

    // ===== UI events =====
    fitAllBtn.addEventListener('click', fitAll);
    filterEl.addEventListener('input', (e)=> doFilter(e.target.value));

    // Sidebar collapse / expand (with floating reopen button)
    let collapsed = false;
    function setCollapsed(val){
      collapsed = !!val;
      appEl.classList.toggle('sidebar-collapsed', collapsed);
      document.getElementById('sidebar').setAttribute('aria-hidden', collapsed ? 'true' : 'false');
      if (collapsed && window.innerWidth > 900) { fab.style.display = 'block'; } else { fab.style.display = 'none'; }
      setTimeout(()=>map.resize(), 60);
    }
    collapseBtn.addEventListener('click', () => setCollapsed(!collapsed));
    expandBtn.addEventListener('click', () => setCollapsed(false));
    window.addEventListener('resize', () => { if (window.innerWidth <= 900) fab.style.display='none'; else if (collapsed) fab.style.display='block'; });

    // Keyboard: S to toggle sidebar, / to focus filter
    document.addEventListener('keydown', (e)=>{
      if (e.key === '/' && document.activeElement !== filterEl) { e.preventDefault(); filterEl.focus(); }
      else if (e.key.toLowerCase() === 's' && window.innerWidth > 900) { setCollapsed(!collapsed); }
      else if (e.key === 'Escape') { popup.remove(); history.replaceState(null, '', location.pathname); const a=document.querySelector('.item.active'); if(a) a.classList.remove('active'); }
    });
  </script>
</body>
</html>
      <div class="sidebar-toggle-fab" id="sidebar-fab">
        <button class="btn" id="expand-sidebar" title="Show sidebar">Show sidebar</button>
      </div>
    </div>
  </div>

  <script>
    // ===== Config =====
    const CONFIG = {
      accessToken: 'pk.eyJ1IjoiZ3JhaGFtLWJjZWxsYXJzIiwiYSI6ImNsbmR1dWZiZjA3OXoyeWxpNTR4Z29wMjMifQ.Dw9ZRaGWdJkYUrFpML7XTw',
      styleUrl: 'mapbox://styles/graham-bcellars/clogch2tt004201oi8i3jgyjy',
      vector: {
        url: 'mapbox://graham-bcellars.clnunbjdd0gcp2nn54qh84xr9-17y6g',
        sourceLayer: 'vineyard-sources' // confirm exact name in Studio → Inspect
      },
      dataset: {
        id: 'clnunbjdd0gcp2nn54qh84xr9',
        username: 'graham-bcellars'
      },
      defaultCenter: [-122.37, 38.45],
      defaultZoom: 10
    };

    mapboxgl.accessToken = CONFIG.accessToken;
    const map = new mapboxgl.Map({
      container: 'map',
      style: CONFIG.styleUrl,
      center: CONFIG.defaultCenter,
      zoom: CONFIG.defaultZoom,
      pitch: 0,
      bearing: 0,
      cooperativeGestures: true,
      attributionControl: true
    });
    map.addControl(new mapboxgl.NavigationControl({showCompass:true}), 'top-right');
    map.addControl(new mapboxgl.FullscreenControl(), 'top-right');

    // ===== State =====
    const listEl = document.getElementById('list');
    const countEl = document.getElementById('count');
    const filterEl = document.getElementById('filter');
    const fitAllBtn = document.getElementById('fit-all');
    const refreshBtn = document.getElementById('refresh');
    const collapseBtn = document.getElementById('collapse');
    const appEl = document.querySelector('.app');
    const fab = document.getElementById('sidebar-fab');
    const expandBtn = document.getElementById('expand-sidebar');
    const popup = new mapboxgl.Popup({ closeButton: true, closeOnClick: true });

    // Index by Name → { center:[lng,lat], bbox:[minX,minY,maxX,maxY], props:{...} }
    let nameIndex = {};
    // Sorted list of names currently visible (after filter)
    let namesList = [];

    // ===== Utilities =====
    function getName(props){ return (props && (props.Name ?? props.name ?? props.NAME)) ? String(props.Name ?? props.name ?? props.NAME) : null; }
    function mergeBbox(acc, b){
      if (!acc) return b.slice();
      return [Math.min(acc[0], b[0]), Math.min(acc[1], b[1]), Math.max(acc[2], b[2]), Math.max(acc[3], b[3])];
    }
    function buildIndexFromDataset(fc){
      const accum = new Map(); // name -> { sum:[lng,lat], n:int, bbox:[...], props }
      for (const f of fc.features || []){
        const nm = getName(f.properties);
        if (!nm) continue;
        let b;
        try { b = turf.bbox(f); } catch(e){ continue; }
        let c;
        try { c = turf.centroid(f).geometry.coordinates; } catch(e){ continue; }
        if (!accum.has(nm)){
          // Choose first non-empty props for SubAVA/Facts/URL
          const p = f.properties || {};
          accum.set(nm, {
            sum:[c[0], c[1]], n:1, bbox:b.slice(),
            props:{
              Name: nm,
              SubAVA: p.SubAVA || p.AVA || '',
              Facts: p.Facts || p.facts || '',
              URL: p.URL || p.url || ''
            }
          });
        } else {
          const rec = accum.get(nm);
          rec.sum[0]+=c[0]; rec.sum[1]+=c[1]; rec.n+=1;
          rec.bbox = mergeBbox(rec.bbox, b);
          // keep existing props
        }
      }
      nameIndex = {};
      for (const [nm, rec] of accum.entries()){
        const center = [rec.sum[0]/rec.n, rec.sum[1]/rec.n];
        nameIndex[nm] = { center, bbox: rec.bbox, props: rec.props };
      }
    }
    function namesAsFeatureCollection(names){
      return {
        type:'FeatureCollection',
        features: names.map(nm => ({
          type:'Feature',
          properties: nameIndex[nm].props,
          geometry: { type:'Point', coordinates: nameIndex[nm].center }
        }))
      };
    }
    function buildList(names){
      listEl.innerHTML = '';
      for (const nm of names){
        const p = nameIndex[nm].props;
        const li = document.createElement('button');
        li.className = 'item';
        li.type = 'button';
        li.dataset.id = nm;
        li.innerHTML = `
          <div class="name">${p.Name}</div>
          <div class="meta">${p.SubAVA || ''}</div>
          <div class="actions">
            <span class="btn primary" aria-hidden="true">Fly To Vineyard</span>
            ${p.URL ? `<a class="btn" href="${p.URL}" target="_blank" rel="noopener" onclick="event.stopPropagation()">Learn more</a>` : ''}
          </div>`;
        li.addEventListener('click', () => selectByName(nm));
        listEl.appendChild(li);
      }
      countEl.textContent = `${names.length} vineyard${names.length===1?'':'s'}`;
    }
    function highlightInList(name){
      document.querySelectorAll('.item').forEach(el => el.classList.toggle('active', el.dataset.id === name));
      const active = document.querySelector('.item.active'); if (active) active.scrollIntoView({block:'nearest', behavior:'smooth'});
    }
    function showPopup(name){
      const rec = nameIndex[name]; if (!rec) return;
      const p = rec.props, lngLat = rec.center;
      const html = `
        <div>
          <div style="font-weight:700; margin-bottom:4px;">${p.Name || 'Vineyard'}</div>
          ${p.SubAVA ? `<div style="font-size:12px; opacity:.8;">${p.SubAVA}</div>` : ''}
          ${p.Facts ? `<div style="margin-top:6px;">${p.Facts}</div>` : ''}
          ${p.URL ? `<div style="margin-top:8px;"><a class="btn" href="${p.URL}" target="_blank" rel="noopener">Learn more →</a></div>` : ''}
        </div>`;
      popup.setLngLat(lngLat).setHTML(html).addTo(map);
    }
    function ensureHighlightLayers(){
      if (!map.getLayer('vineyard-selected-fill')) {
        map.addLayer({
          id: 'vineyard-selected-fill',
          type: 'fill',
          source: 'vineyard-polygons',
          'source-layer': CONFIG.vector.sourceLayer,
          paint: { 'fill-color': '#ffffff', 'fill-opacity': 0.25 },
          filter: ['==', ['get', 'Name'], '___none___']
        }, 'vineyard-outline');
      }
      if (!map.getLayer('vineyard-selected-line')) {
        map.addLayer({
          id: 'vineyard-selected-line',
          type: 'line',
          source: 'vineyard-polygons',
          'source-layer': CONFIG.vector.sourceLayer,
          paint: { 'line-color': '#ffffff', 'line-width': 2.5 },
          filter: ['==', ['get', 'Name'], '___none___']
        });
      }
    }
    function setHighlight(name){
      ensureHighlightLayers();
      map.setFilter('vineyard-selected-fill', ['==', ['get','Name'], name]);
      map.setFilter('vineyard-selected-line', ['==', ['get','Name'], name]);
    }
    function selectByName(name){
      const rec = nameIndex[name];
      if (!rec) return;
      setHighlight(name);
      // Fit to dataset bbox (robust, doesn't rely on rendered tiles)
      const b = rec.bbox;
      if (b) {
        map.fitBounds([[b[0], b[1]], [b[2], b[3]]], { padding: 50, maxZoom: 15 });
        setTimeout(() => map.easeTo({ pitch: 75, duration: 300 }), 50);
      } else {
        map.flyTo({ center: rec.center, zoom: 15, pitch: 75, speed: 0.8, curve: 1.6, essential: true });
      }
      showPopup(name);
      highlightInList(name);
      history.replaceState(null, '', `#id=${encodeURIComponent(name)}`);
    }
    function fitAll(){
      const names = namesList.length ? namesList : Object.keys(nameIndex);
      if (!names.length) return;
      const coords = names.map(nm => nameIndex[nm].center);
      const b = coords.reduce((bounds, c) => bounds.extend(c), new mapboxgl.LngLatBounds(coords[0], coords[0]));
      map.fitBounds(b, { padding: 50 });
    }
    function debounce(fn, ms=200){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; }
    const doFilter = debounce((q)=>{
      const term = q.trim().toLowerCase();
      const names = Object.keys(nameIndex).filter(nm => {
        const p = nameIndex[nm].props;
        return [p.Name, p.SubAVA, p.Facts].some(v => (v||'').toLowerCase().includes(term));
      }).sort((a,b)=> a.localeCompare(b));
      namesList = names;
      buildList(namesList);
    }, 160);

    // ===== Data plumbing =====
    async function fetchDataset() {
      const url = `https://api.mapbox.com/datasets/v1/${CONFIG.dataset.username}/${CONFIG.dataset.id}/features?access_token=${encodeURIComponent(mapboxgl.accessToken)}`;
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) throw new Error('Dataset fetch failed: ' + res.status);
      const fc = await res.json();
      if (!fc || !fc.features) throw new Error('No features in dataset.');
      return fc;
    }

    async function rebuildFromDataset(){
      const fc = await fetchDataset();
      buildIndexFromDataset(fc);
      // Build sidebar list (sorted, deduped)
      namesList = Object.keys(nameIndex).sort((a,b)=> a.localeCompare(b));
      buildList(namesList);

      // Labels from grouped centers (no markers)
      const labelsFC = namesAsFeatureCollection(namesList);
      if (map.getSource('vineyard-points')) map.removeSource('vineyard-points');
      if (map.getLayer('vineyard-labels')) map.removeLayer('vineyard-labels');
      map.addSource('vineyard-points', { type:'geojson', data: labelsFC });
      map.addLayer({
        id:'vineyard-labels',
        type:'symbol',
        source:'vineyard-points',
        minzoom: 12,
        layout:{ 'text-field':['get','Name'], 'text-size':12, 'text-offset':[0,1.1], 'text-anchor':'top', 'text-allow-overlap': true },
        paint:{ 'text-color':'#eef2f7', 'text-halo-color':'#0b0c10', 'text-halo-width':1.2 }
      });
    }

    // ===== Init =====
    map.on('load', async () => {
      // Polygons from tileset
      map.addSource('vineyard-polygons', { type:'vector', url: CONFIG.vector.url });
      map.addLayer({ id:'vineyard-fill', type:'fill', source:'vineyard-polygons', 'source-layer': CONFIG.vector.sourceLayer, paint:{ 'fill-color':'#c64b4b', 'fill-opacity':0.35 } });
      map.addLayer({ id:'vineyard-outline', type:'line', source:'vineyard-polygons', 'source-layer': CONFIG.vector.sourceLayer, paint:{ 'line-color':'#c64b4b', 'line-width':1.2 } });

      try {
        await rebuildFromDataset();
        fitAll();
      } catch (e) {
        console.error(e);
        alert('Failed to load dataset features. Check token or dataset permissions.');
      }

      // Polygon click -> select by Name (with fallbacks on key casing)
      map.on('click','vineyard-fill', (e)=>{
        const f = e.features && e.features[0]; if (!f) return;
        const name = getName(f.properties);
        if (name) selectByName(name);
      });
      map.on('mouseenter','vineyard-fill', () => map.getCanvas().style.cursor='pointer');
      map.on('mouseleave','vineyard-fill', () => map.getCanvas().style.cursor='');

      // Deep link
      const m = location.hash.match(/id=([^&]+)/); if (m) setTimeout(()=>selectByName(decodeURIComponent(m[1])), 300);
    });

    // ===== UI events =====
    fitAllBtn.addEventListener('click', fitAll);
    refreshBtn.addEventListener('click', async () => {
      try { await rebuildFromDataset(); fitAll(); } catch(e){ console.error(e); alert('Refresh failed. See console.'); }
    });
    filterEl.addEventListener('input', (e)=> doFilter(e.target.value));

    // Sidebar collapse / expand (with floating reopen button)
    let collapsed = false;
    function setCollapsed(val){
      collapsed = !!val;
      appEl.classList.toggle('sidebar-collapsed', collapsed);
      document.getElementById('sidebar').setAttribute('aria-hidden', collapsed ? 'true' : 'false');
      if (collapsed && window.innerWidth > 900) { fab.style.display = 'block'; } else { fab.style.display = 'none'; }
      setTimeout(()=>map.resize(), 60);
    }
    collapseBtn.addEventListener('click', () => setCollapsed(!collapsed));
    expandBtn.addEventListener('click', () => setCollapsed(false));
    window.addEventListener('resize', () => { if (window.innerWidth <= 900) fab.style.display='none'; else if (collapsed) fab.style.display='block'; });

    // Keyboard: S to toggle sidebar, / to focus filter
    document.addEventListener('keydown', (e)=>{
      if (e.key === '/' && document.activeElement !== filterEl) { e.preventDefault(); filterEl.focus(); }
      else if (e.key.toLowerCase() === 's' && window.innerWidth > 900) { setCollapsed(!collapsed); }
      else if (e.key === 'Escape') { popup.remove(); history.replaceState(null, '', location.pathname); const a=document.querySelector('.item.active'); if(a) a.classList.remove('active'); }
    });
  </script>
</body>
</html>
  </div>

  <script>
    // ===== Config =====
    const CONFIG = {
      // User token provided
      accessToken: 'pk.eyJ1IjoiZ3JhaGFtLWJjZWxsYXJzIiwiYSI6ImNsbmR1dWZiZjA3OXoyeWxpNTR4Z29wMjMifQ.Dw9ZRaGWdJkYUrFpML7XTw',
      styleUrl: 'mapbox://styles/graham-bcellars/clogch2tt004201oi8i3jgyjy',
      // New tileset + source-layer
      vector: {
        url: 'mapbox://graham-bcellars.clnunbjdd0gcp2nn54qh84xr9-17y6g',
        sourceLayer: 'vineyard-sources' // confirm exact name in Studio if needed
      },
      dataset: {
        id: 'clnunbjdd0gcp2nn54qh84xr9',
        username: 'graham-bcellars'
      },
      defaultCenter: [-122.37, 38.45],
      defaultZoom: 10
    };

    mapboxgl.accessToken = CONFIG.accessToken;
    const map = new mapboxgl.Map({
      container: 'map',
      style: CONFIG.styleUrl,
      center: CONFIG.defaultCenter,
      zoom: CONFIG.defaultZoom,
      pitch: 0,
      bearing: 0,
      cooperativeGestures: true,
      attributionControl: true
    });
    map.addControl(new mapboxgl.NavigationControl({showCompass:true}), 'top-right');
    map.addControl(new mapboxgl.FullscreenControl(), 'top-right');

    // ===== State =====
    const listEl = document.getElementById('list');
    const countEl = document.getElementById('count');
    const filterEl = document.getElementById('filter');
    const fitAllBtn = document.getElementById('fit-all');
    const refreshBtn = document.getElementById('refresh');
    const collapseBtn = document.getElementById('collapse');
    const appEl = document.querySelector('.app');
    const fab = document.getElementById('sidebar-fab');
    const expandBtn = document.getElementById('expand-sidebar');
    const popup = new mapboxgl.Popup({ closeButton: true, closeOnClick: true });

    let allPoints = [];   // deduped points by Name (for sidebar/popup only)
    let filteredPoints = [];

    // ===== Utilities =====
    function groupPointsByName(geojson){
      const groups = new Map();
      for (const f of geojson.features) {
        const name = f.properties && f.properties.Name;
        if (!name) continue;
        if (!groups.has(name)) {
          groups.set(name, { coords: [], props: f.properties });
        }
        groups.get(name).coords.push(f.geometry.coordinates);
      }
      const out = { type:'FeatureCollection', features: [] };
      for (const [name, rec] of groups.entries()) {
        const n = rec.coords.length;
        const avg = rec.coords.reduce((acc, c) => [acc[0]+c[0], acc[1]+c[1]], [0,0]).map(v => v/n);
        out.features.push({
          type:'Feature',
          properties: rec.props,
          geometry: { type:'Point', coordinates: avg }
        });
      }
      return out;
    }
    function showPopupFor(f) {
      const p = f.properties || {};
      const [lng,lat] = f.geometry.coordinates;
      const html = `
        <div>
          <div style="font-weight:700; margin-bottom:4px;">${p.Name || 'Vineyard'}</div>
          ${p.SubAVA ? `<div style="font-size:12px; opacity:.8;">${p.SubAVA}</div>` : ''}
          ${p.Facts ? `<div style="margin-top:6px;">${p.Facts}</div>` : ''}
          ${p.URL ? `<div style="margin-top:8px;"><a class="btn" href="${p.URL}" target="_blank" rel="noopener">Learn more →</a></div>` : ''}
        </div>`;
      popup.setLngLat([lng,lat]).setHTML(html).addTo(map);
    }
    function buildLists(items) {
      listEl.innerHTML = '';
      for (const f of items) {
      items.sort((a,b)=> (a.properties?.Name||'').localeCompare(b.properties?.Name||''));
        const p = f.properties || {};
        const li = document.createElement('button');
        li.className = 'item';
        li.type = 'button';
        li.dataset.id = p.Name;
        li.innerHTML = `
          <div class="name">${p.Name}</div>
          <div class="meta">${p.SubAVA || ''}</div>
          <div class="actions">
            <span class="btn primary" aria-hidden="true">Fly To Vineyard</span>
            ${p.URL ? `<a class="btn" href="${p.URL}" target="_blank" rel="noopener" onclick="event.stopPropagation()">Learn more</a>` : ''}
          </div>`;
        li.addEventListener('click', () => selectByName(p.Name));
        listEl.appendChild(li);
      }
      countEl.textContent = `${items.length} vineyard${items.length===1?'':'s'}`;
    }
    function highlightInList(name){
      document.querySelectorAll('.item').forEach(el => el.classList.toggle('active', el.dataset.id === name));
      const active = document.querySelector('.item.active'); if (active) active.scrollIntoView({block:'nearest', behavior:'smooth'});
    }
    function flyToBoundsOrCenter(bbox){
      if (!bbox) return;
      // Fit to bounds, capped at zoom 15, then set pitch 75
      map.fitBounds([[bbox[0], bbox[1]], [bbox[2], bbox[3]]], { padding: 50, maxZoom: 15 });
      setTimeout(() => map.easeTo({ pitch: 75, duration: 300 }), 50);
    }
    function ensureHighlightLayers(){
      if (!map.getLayer('vineyard-selected-fill')) {
        map.addLayer({
          id: 'vineyard-selected-fill',
          type: 'fill',
          source: 'vineyard-polygons',
          'source-layer': CONFIG.vector.sourceLayer,
          paint: { 'fill-color': '#ffffff', 'fill-opacity': 0.25 },
          filter: ['==', ['get', 'Name'], '___none___']
        }, 'vineyard-outline');
      }
      if (!map.getLayer('vineyard-selected-line')) {
        map.addLayer({
          id: 'vineyard-selected-line',
          type: 'line',
          source: 'vineyard-polygons',
          'source-layer': CONFIG.vector.sourceLayer,
          paint: { 'line-color': '#ffffff', 'line-width': 2.5 },
          filter: ['==', ['get', 'Name'], '___none___']
        });
      }
    }
    function setHighlight(name){
      ensureHighlightLayers();
      map.setFilter('vineyard-selected-fill', ['==', ['get','Name'], name]);
      map.setFilter('vineyard-selected-line', ['==', ['get','Name'], name]);
    }
    function selectByName(name){
      if (!name) return;
      // Highlight & fly to polygon bounds
      const polys = map.querySourceFeatures('vineyard-polygons', { sourceLayer: CONFIG.vector.sourceLayer, filter: ['==', ['get','Name'], name] });
      if (polys && polys.length) {
        setHighlight(name);
        try {
          // Merge all polygons with same Name and compute combined bbox
          let bbox = null;
          polys.forEach(f => {
            const b = turf.bbox(f);
            if (!bbox) bbox = b; else {
              bbox = [Math.min(bbox[0], b[0]), Math.min(bbox[1], b[1]), Math.max(bbox[2], b[2]), Math.max(bbox[3], b[3])];
            }
          });
          flyToBoundsOrCenter(bbox);
        } catch(e){ /* fallback to centroid below */ }
      }
      // Popup from centroid list (attributes)
      const pt = (filteredPoints.length ? filteredPoints : allPoints).find(ft => (ft.properties && ft.properties.Name) === name);
      if (pt) showPopupFor(pt);
      highlightInList(name);
      history.replaceState(null, '', `#id=${encodeURIComponent(name)}`);
    }
    function fitAll(){
      const feats = filteredPoints.length ? filteredPoints : allPoints;
      if (!feats.length) return;
      const b = feats.reduce((bounds, ft) => bounds.extend(ft.geometry.coordinates), new mapboxgl.LngLatBounds(feats[0].geometry.coordinates, feats[0].geometry.coordinates));
      map.fitBounds(b, { padding: 50 });
    }

    function debounce(fn, ms=200){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; }
    const doFilter = debounce((q)=>{
      const term = q.trim().toLowerCase();
      filteredPoints = !term ? allPoints.slice() : allPoints.filter(f => {
        const p = f.properties || {};
        return [p.Name, p.SubAVA, p.Facts].some(v => (v||'').toLowerCase().includes(term));
      });
      buildLists(filteredPoints);
    }, 160);

    // ===== Data plumbing =====
    async function fetchDatasetFeatures() {
      const base = 'https://api.mapbox.com/datasets/v1/';
      const url = base + CONFIG.dataset.username + '/' + CONFIG.dataset.id + '/features?access_token=' + encodeURIComponent(mapboxgl.accessToken);
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) throw new Error('Dataset fetch failed: ' + res.status);
      const fc = await res.json();
      if (!fc || !fc.features) throw new Error('No features in dataset.');

      // Build centroids; keep properties
      const pts = [];
      for (const f of fc.features) {
        const p = f.properties || {};
        const name = (p.Name !== undefined && p.Name !== null) ? String(p.Name) : null;
        if (!name) continue;
        let center;
        if (f.geometry && f.geometry.type === 'Point') center = f.geometry.coordinates;
        else {
          try { center = turf.centroid(f).geometry.coordinates; } catch(e) { continue; }
        }
        pts.push({
          type:'Feature',
          properties: {
            Name: name,
            SubAVA: p.SubAVA || p.AVA || '',
            Facts: p.Facts || p.facts || '',
            URL: p.URL || p.url || ''
          },
          geometry: { type:'Point', coordinates: center }
        });
      }
      return groupPointsByName({ type:'FeatureCollection', features: pts });
    }

    async function addPointSource(geojson) {
      allPoints = geojson.features.slice();
      filteredPoints = allPoints.slice();
      buildLists(filteredPoints);

      // Optional: labels at zoom >= 12 (no marker dots)
      if (map.getSource('vineyard-points')) map.removeSource('vineyard-points');
      if (map.getLayer('vineyard-labels')) map.removeLayer('vineyard-labels');

      map.addSource('vineyard-points', { type:'geojson', data: geojson });
      map.addLayer({
        id:'vineyard-labels',
        type:'symbol',
        source:'vineyard-points',
        minzoom: 12,
        layout:{ 'text-field':['get','Name'], 'text-size':12, 'text-offset':[0,1.1], 'text-anchor':'top', 'text-allow-overlap': true },
        paint:{ 'text-color':'#eef2f7', 'text-halo-color':'#0b0c10', 'text-halo-width':1.2 }
      });
    }

    // ===== Init =====
    map.on('load', async () => {
      // Polygons from tileset
      map.addSource('vineyard-polygons', { type:'vector', url: CONFIG.vector.url });
      map.addLayer({ id:'vineyard-fill', type:'fill', source:'vineyard-polygons', 'source-layer': CONFIG.vector.sourceLayer, paint:{ 'fill-color':'#c64b4b', 'fill-opacity':0.35 } });
      map.addLayer({ id:'vineyard-outline', type:'line', source:'vineyard-polygons', 'source-layer': CONFIG.vector.sourceLayer, paint:{ 'line-color':'#c64b4b', 'line-width':1.2 } });

      // Points/attributes from dataset (not drawn as markers)
      try {
        let points = await fetchDatasetFeatures();
        points = groupPointsByName(points);
        await addPointSource(points);
        fitAll();
      } catch (e) {
        console.error(e);
        alert('Failed to load dataset features. Check access token or dataset permissions.');
      }

      // Polygon click -> select by Name
      map.on('click','vineyard-fill', (e)=>{
        const f = e.features && e.features[0]; if (!f) return;
        const name = f.properties && f.properties.Name; if (name) selectByName(String(name));
      });
      map.on('mouseenter','vineyard-fill', () => map.getCanvas().style.cursor='pointer');
      map.on('mouseleave','vineyard-fill', () => map.getCanvas().style.cursor='');

      const m = location.hash.match(/id=([^&]+)/); if (m) setTimeout(()=>selectByName(decodeURIComponent(m[1])), 300);
    });

    // ===== UI events =====
    fitAllBtn.addEventListener('click', fitAll);
    refreshBtn.addEventListener('click', async () => {
      try { let pts = await fetchDatasetFeatures(); pts = groupPointsByName(pts); await addPointSource(pts); fitAll(); }
      catch(e) { console.error(e); alert('Refresh failed. See console.'); }
    });
    filterEl.addEventListener('input', (e)=> doFilter(e.target.value));

    // Sidebar collapse / expand
    let collapsed = false;
    function setCollapsed(val){
      collapsed = !!val;
      appEl.classList.toggle('sidebar-collapsed', collapsed);
      document.getElementById('sidebar').setAttribute('aria-hidden', collapsed ? 'true' : 'false');
      if (collapsed && window.innerWidth > 900) { fab.style.display = 'block'; } else { fab.style.display = 'none'; }
      setTimeout(()=>map.resize(), 60);
    }
    collapseBtn.addEventListener('click', () => setCollapsed(!collapsed));
    expandBtn.addEventListener('click', () => setCollapsed(false));
    window.addEventListener('resize', () => { if (window.innerWidth <= 900) fab.style.display='none'; else if (collapsed) fab.style.display='block'; });

    // Keyboard: S to toggle sidebar, / to focus filter
    document.addEventListener('keydown', (e)=>{
      if (e.key === '/' && document.activeElement !== filterEl) { e.preventDefault(); filterEl.focus(); }
      else if (e.key.toLowerCase() === 's' && window.innerWidth > 900) { setCollapsed(!collapsed); }
      else if (e.key === 'Escape') { popup.remove(); history.replaceState(null, '', location.pathname); const a=document.querySelector('.item.active'); if(a) a.classList.remove('active'); }
    });
  </script>
</body>
</html>
  </div>

  <script>
    // ===== Config =====
    const CONFIG = {
      // User token provided
      accessToken: 'pk.eyJ1IjoiZ3JhaGFtLWJjZWxsYXJzIiwiYSI6ImNsbmR1dWZiZjA3OXoyeWxpNTR4Z29wMjMifQ.Dw9ZRaGWdJkYUrFpML7XTw',
      styleUrl: 'mapbox://styles/graham-bcellars/clogch2tt004201oi8i3jgyjy',
      // New tileset + source-layer
      vector: {
        url: 'mapbox://graham-bcellars.clnunbjdd0gcp2nn54qh84xr9-17y6g',
        sourceLayer: 'vineyard-sources' // confirm exact name in Studio if needed
      },
      dataset: {
        id: 'clnunbjdd0gcp2nn54qh84xr9',
        username: 'graham-bcellars'
      },
      defaultCenter: [-122.37, 38.45],
      defaultZoom: 10
    };

    mapboxgl.accessToken = CONFIG.accessToken;
    const map = new mapboxgl.Map({
      container: 'map',
      style: CONFIG.styleUrl,
      center: CONFIG.defaultCenter,
      zoom: CONFIG.defaultZoom,
      pitch: 0,
      bearing: 0,
      cooperativeGestures: true,
      attributionControl: true
    });
    map.addControl(new mapboxgl.NavigationControl({showCompass:true}), 'top-right');
    map.addControl(new mapboxgl.FullscreenControl(), 'top-right');

    // ===== State =====
    const listEl = document.getElementById('list');
    const countEl = document.getElementById('count');
    const filterEl = document.getElementById('filter');
    const fitAllBtn = document.getElementById('fit-all');
    const refreshBtn = document.getElementById('refresh');
    const collapseBtn = document.getElementById('collapse');
    const appEl = document.querySelector('.app');
    const fab = document.getElementById('sidebar-fab');
    const expandBtn = document.getElementById('expand-sidebar');
    const popup = new mapboxgl.Popup({ closeButton: true, closeOnClick: true });

    let allPoints = [];   // deduped points by Name (for sidebar/popup only)
    let filteredPoints = [];

    // ===== Utilities =====
    function groupPointsByName(geojson){
      const groups = new Map();
      for (const f of geojson.features) {
        const name = f.properties && f.properties.Name;
        if (!name) continue;
        if (!groups.has(name)) {
          groups.set(name, { coords: [], props: f.properties });
        }
        groups.get(name).coords.push(f.geometry.coordinates);
      }
      const out = { type:'FeatureCollection', features: [] };
      for (const [name, rec] of groups.entries()) {
        const n = rec.coords.length;
        const avg = rec.coords.reduce((acc, c) => [acc[0]+c[0], acc[1]+c[1]], [0,0]).map(v => v/n);
        out.features.push({
          type:'Feature',
          properties: rec.props,
          geometry: { type:'Point', coordinates: avg }
        });
      }
      return out;
    }
    function showPopupFor(f) {
      const p = f.properties || {};
      const [lng,lat] = f.geometry.coordinates;
      const html = `
        <div>
          <div style="font-weight:700; margin-bottom:4px;">${p.Name || 'Vineyard'}</div>
          ${p.SubAVA ? `<div style="font-size:12px; opacity:.8;">${p.SubAVA}</div>` : ''}
          ${p.Facts ? `<div style="margin-top:6px;">${p.Facts}</div>` : ''}
          ${p.URL ? `<div style="margin-top:8px;"><a class="btn" href="${p.URL}" target="_blank" rel="noopener">Learn more →</a></div>` : ''}
        </div>`;
      popup.setLngLat([lng,lat]).setHTML(html).addTo(map);
    }
    function buildLists(items) {
      listEl.innerHTML = '';
      for (const f of items) {
      items.sort((a,b)=> (a.properties?.Name||'').localeCompare(b.properties?.Name||''));
        const p = f.properties || {};
        const li = document.createElement('button');
        li.className = 'item';
        li.type = 'button';
        li.dataset.id = p.Name;
        li.innerHTML = `
          <div class="name">${p.Name}</div>
          <div class="meta">${p.SubAVA || ''}</div>
          <div class="actions">
            <span class="btn primary" aria-hidden="true">Fly To Vineyard</span>
            ${p.URL ? `<a class="btn" href="${p.URL}" target="_blank" rel="noopener" onclick="event.stopPropagation()">Learn more</a>` : ''}
          </div>`;
        li.addEventListener('click', () => selectByName(p.Name));
        listEl.appendChild(li);
      }
      countEl.textContent = `${items.length} vineyard${items.length===1?'':'s'}`;
    }
    function highlightInList(name){
      document.querySelectorAll('.item').forEach(el => el.classList.toggle('active', el.dataset.id === name));
      const active = document.querySelector('.item.active'); if (active) active.scrollIntoView({block:'nearest', behavior:'smooth'});
    }
    function flyToBoundsOrCenter(bbox){
      if (!bbox) return;
      // Fit to bounds, capped at zoom 15, then set pitch 75
      map.fitBounds([[bbox[0], bbox[1]], [bbox[2], bbox[3]]], { padding: 50, maxZoom: 15 });
      setTimeout(() => map.easeTo({ pitch: 75, duration: 300 }), 50);
    }
    function ensureHighlightLayers(){
      if (!map.getLayer('vineyard-selected-fill')) {
        map.addLayer({
          id: 'vineyard-selected-fill',
          type: 'fill',
          source: 'vineyard-polygons',
          'source-layer': CONFIG.vector.sourceLayer,
          paint: { 'fill-color': '#ffffff', 'fill-opacity': 0.25 },
          filter: ['==', ['get', 'Name'], '___none___']
        }, 'vineyard-outline');
      }
      if (!map.getLayer('vineyard-selected-line')) {
        map.addLayer({
          id: 'vineyard-selected-line',
          type: 'line',
          source: 'vineyard-polygons',
          'source-layer': CONFIG.vector.sourceLayer,
          paint: { 'line-color': '#ffffff', 'line-width': 2.5 },
          filter: ['==', ['get', 'Name'], '___none___']
        });
      }
    }
    function setHighlight(name){
      ensureHighlightLayers();
      map.setFilter('vineyard-selected-fill', ['==', ['get','Name'], name]);
      map.setFilter('vineyard-selected-line', ['==', ['get','Name'], name]);
    }
    function selectByName(name){
      if (!name) return;
      // Highlight & fly to polygon bounds
      const polys = map.querySourceFeatures('vineyard-polygons', { sourceLayer: CONFIG.vector.sourceLayer, filter: ['==', ['get','Name'], name] });
      if (polys && polys.length) {
        setHighlight(name);
        try {
          // Merge all polygons with same Name and compute combined bbox
          let bbox = null;
          polys.forEach(f => {
            const b = turf.bbox(f);
            if (!bbox) bbox = b; else {
              bbox = [Math.min(bbox[0], b[0]), Math.min(bbox[1], b[1]), Math.max(bbox[2], b[2]), Math.max(bbox[3], b[3])];
            }
          });
          flyToBoundsOrCenter(bbox);
        } catch(e){ /* fallback to centroid below */ }
      }
      // Popup from centroid list (attributes)
      const pt = (filteredPoints.length ? filteredPoints : allPoints).find(ft => (ft.properties && ft.properties.Name) === name);
      if (pt) showPopupFor(pt);
      highlightInList(name);
      history.replaceState(null, '', `#id=${encodeURIComponent(name)}`);
    }
    function fitAll(){
      const feats = filteredPoints.length ? filteredPoints : allPoints;
      if (!feats.length) return;
      const b = feats.reduce((bounds, ft) => bounds.extend(ft.geometry.coordinates), new mapboxgl.LngLatBounds(feats[0].geometry.coordinates, feats[0].geometry.coordinates));
      map.fitBounds(b, { padding: 50 });
    }

    function debounce(fn, ms=200){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; }
    const doFilter = debounce((q)=>{
      const term = q.trim().toLowerCase();
      filteredPoints = !term ? allPoints.slice() : allPoints.filter(f => {
        const p = f.properties || {};
        return [p.Name, p.SubAVA, p.Facts].some(v => (v||'').toLowerCase().includes(term));
      });
      buildLists(filteredPoints);
    }, 160);

    // ===== Data plumbing =====
    async function fetchDatasetFeatures() {
      const base = 'https://api.mapbox.com/datasets/v1/';
      const url = base + CONFIG.dataset.username + '/' + CONFIG.dataset.id + '/features?access_token=' + encodeURIComponent(mapboxgl.accessToken);
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) throw new Error('Dataset fetch failed: ' + res.status);
      const fc = await res.json();
      if (!fc || !fc.features) throw new Error('No features in dataset.');

      // Build centroids; keep properties
      const pts = [];
      for (const f of fc.features) {
        const p = f.properties || {};
        const name = (p.Name !== undefined && p.Name !== null) ? String(p.Name) : null;
        if (!name) continue;
        let center;
        if (f.geometry && f.geometry.type === 'Point') center = f.geometry.coordinates;
        else {
          try { center = turf.centroid(f).geometry.coordinates; } catch(e) { continue; }
        }
        pts.push({
          type:'Feature',
          properties: {
            Name: name,
            SubAVA: p.SubAVA || p.AVA || '',
            Facts: p.Facts || p.facts || '',
            URL: p.URL || p.url || ''
          },
          geometry: { type:'Point', coordinates: center }
        });
      }
      return groupPointsByName({ type:'FeatureCollection', features: pts });
    }

    async function addPointSource(geojson) {
      allPoints = geojson.features.slice();
      filteredPoints = allPoints.slice();
      buildLists(filteredPoints);

      // Optional: labels at zoom >= 12 (no marker dots)
      if (map.getSource('vineyard-points')) map.removeSource('vineyard-points');
      if (map.getLayer('vineyard-labels')) map.removeLayer('vineyard-labels');

      map.addSource('vineyard-points', { type:'geojson', data: geojson });
      map.addLayer({
        id:'vineyard-labels',
        type:'symbol',
        source:'vineyard-points',
        minzoom: 12,
        layout:{ 'text-field':['get','Name'], 'text-size':12, 'text-offset':[0,1.1], 'text-anchor':'top', 'text-allow-overlap': true },
        paint:{ 'text-color':'#eef2f7', 'text-halo-color':'#0b0c10', 'text-halo-width':1.2 }
      });
    }

    // ===== Init =====
    map.on('load', async () => {
      // Polygons from tileset
      map.addSource('vineyard-polygons', { type:'vector', url: CONFIG.vector.url });
      map.addLayer({ id:'vineyard-fill', type:'fill', source:'vineyard-polygons', 'source-layer': CONFIG.vector.sourceLayer, paint:{ 'fill-color':'#c64b4b', 'fill-opacity':0.35 } });
      map.addLayer({ id:'vineyard-outline', type:'line', source:'vineyard-polygons', 'source-layer': CONFIG.vector.sourceLayer, paint:{ 'line-color':'#c64b4b', 'line-width':1.2 } });

      // Points/attributes from dataset (not drawn as markers)
      try {
        const points = await fetchDatasetFeatures();
        await addPointSource(points);
        fitAll();
      } catch (e) {
        console.error(e);
        alert('Failed to load dataset features. Check access token or dataset permissions.');
      }

      // Polygon click -> select by Name
      map.on('click','vineyard-fill', (e)=>{
        const f = e.features && e.features[0]; if (!f) return;
        const name = f.properties && f.properties.Name; if (name) selectByName(String(name));
      });
      map.on('mouseenter','vineyard-fill', () => map.getCanvas().style.cursor='pointer');
      map.on('mouseleave','vineyard-fill', () => map.getCanvas().style.cursor='');

      const m = location.hash.match(/id=([^&]+)/); if (m) setTimeout(()=>selectByName(decodeURIComponent(m[1])), 300);
    });

    // ===== UI events =====
    fitAllBtn.addEventListener('click', fitAll);
    refreshBtn.addEventListener('click', async () => {
      try { const pts = await fetchDatasetFeatures(); await addPointSource(pts); fitAll(); }
      catch(e) { console.error(e); alert('Refresh failed. See console.'); }
    });
    filterEl.addEventListener('input', (e)=> doFilter(e.target.value));

    // Sidebar collapse / expand
    let collapsed = false;
    function setCollapsed(val){
      collapsed = !!val;
      appEl.classList.toggle('sidebar-collapsed', collapsed);
      document.getElementById('sidebar').setAttribute('aria-hidden', collapsed ? 'true' : 'false');
      if (collapsed && window.innerWidth > 900) { fab.style.display = 'block'; } else { fab.style.display = 'none'; }
      setTimeout(()=>map.resize(), 60);
    }
    collapseBtn.addEventListener('click', () => setCollapsed(!collapsed));
    expandBtn.addEventListener('click', () => setCollapsed(false));
    window.addEventListener('resize', () => { if (window.innerWidth <= 900) fab.style.display='none'; else if (collapsed) fab.style.display='block'; });

    // Keyboard: S to toggle sidebar, / to focus filter
    document.addEventListener('keydown', (e)=>{
      if (e.key === '/' && document.activeElement !== filterEl) { e.preventDefault(); filterEl.focus(); }
      else if (e.key.toLowerCase() === 's' && window.innerWidth > 900) { setCollapsed(!collapsed); }
      else if (e.key === 'Escape') { popup.remove(); history.replaceState(null, '', location.pathname); const a=document.querySelector('.item.active'); if(a) a.classList.remove('active'); }
    });
  </script>
</body>
</html>
  <script>
    // ===== Config =====
    const CONFIG = {
      accessToken: 'pk.eyJ1IjoiZ3JhaGFtLWJjZWxsYXJzIiwiYSI6ImNsbmR1dWZiZjA3OXoyeWxpNTR4Z29wMjMifQ.Dw9ZRaGWdJkYUrFpML7XTw', // TODO: set this
      styleUrl: 'mapbox://styles/graham-bcellars/clogch2tt004201oi8i3jgyjy',
      vector: {
        url: 'mapbox://graham-bcellars.clnunbjdd0gcp2nn54qh84xr9-17y6g',
        sourceLayer: 'vineyard-sources'
      },
      dataset: {
        id: 'clnunbjdd0gcp2nn54qh84xr9',
        username: 'graham-bcellars' // adjust if needed
      },
      defaultCenter: [-122.37, 38.45],
      defaultZoom: 10,
      startPitch: 50
    };

    mapboxgl.accessToken = CONFIG.accessToken;
    const map = new mapboxgl.Map({
      container: 'map',
      style: CONFIG.styleUrl,
      center: CONFIG.defaultCenter,
      zoom: CONFIG.defaultZoom,
      pitch: CONFIG.startPitch,
      bearing: 0,
      cooperativeGestures: true,
      attributionControl: true
    });
    map.addControl(new mapboxgl.NavigationControl({showCompass:true}), 'top-right');
    map.addControl(new mapboxgl.FullscreenControl(), 'top-right');

    // ===== State =====
    const listEl = document.getElementById('list');
    const countEl = document.getElementById('count');
    const filterEl = document.getElementById('filter');
    const fitAllBtn = document.getElementById('fit-all');
    const refreshBtn = document.getElementById('refresh');
    const collapseBtn = document.getElementById('collapse');
    const appEl = document.querySelector('.app');
    const fab = document.getElementById('sidebar-fab');
    const expandBtn = document.getElementById('expand-sidebar');

    let allPoints = []; // centroids from dataset
    let filteredPoints = [];
    const popup = new mapboxgl.Popup({ closeButton: true, closeOnClick: true });

    // ===== Utilities =====
    function groupPointsByName(geojson){
      const groups = new Map();
      for (const f of geojson.features) {
        const name = f.properties && f.properties.Name;
        if (!name) continue;
        if (!groups.has(name)) {
          groups.set(name, { coords: [], props: f.properties });
        }
        groups.get(name).coords.push(f.geometry.coordinates);
      }
      const out = { type:'FeatureCollection', features: [] };
      for (const [name, rec] of groups.entries()) {
        // Average coordinates for a stable representative point
        const n = rec.coords.length;
        const avg = rec.coords.reduce((acc, c) => [acc[0]+c[0], acc[1]+c[1]], [0,0]).map(v => v/n);
        out.features.push({
          type:'Feature',
          properties: rec.props, // Name/SubAVA/Facts/URL from first feature
          geometry: { type:'Point', coordinates: avg }
        });
      }
      return out;
    }

    function featureName(f) { return (f.properties && f.properties.Name) ? String(f.properties.Name) : 'unknown'; }
    function announceCount(n) { countEl.textContent = `${n} vineyard${n===1?'':'s'}`; }
    function buildLists(items) {
      listEl.innerHTML = '';
      for (const f of items) {
        const p = f.properties || {};
        const li = document.createElement('button');
        li.className = 'item';
        li.type = 'button';
        li.dataset.id = p.Name;
        li.innerHTML = `
          <div class="name">${p.Name}</div>
          <div class="meta">${p.SubAVA || ''}</div>
          <div class="actions">
            <span class="btn" aria-hidden="true">Fly to</span>
            ${p.URL ? `<a class="btn" href="${p.URL}" target="_blank" rel="noopener" onclick="event.stopPropagation()">Learn more</a>` : ''}
          </div>`;
        li.addEventListener('click', () => selectByName(p.Name));
        listEl.appendChild(li);
      }
      announceCount(items.length);
    }
    function highlightInList(name) {
      document.querySelectorAll('.item').forEach(el => el.classList.toggle('active', el.dataset.id === name));
      const active = document.querySelector('.item.active'); if (active) active.scrollIntoView({block:'nearest', behavior:'smooth'});
    }
    function flyTo(lngLat){ map.flyTo({ center: lngLat, zoom: 15, pitch: 75, speed: 0.8, curve: 1.6, essential: true }); }); }
    function showPopupFor(f) {
      const p = f.properties || {};
      const [lng,lat] = f.geometry.coordinates;
      const html = `
        <div>
          <div style="font-weight:700; margin-bottom:4px;">${p.Name || 'Vineyard'}</div>
          ${p.SubAVA ? `<div style="font-size:12px; opacity:.8;">${p.SubAVA}</div>` : ''}
          ${p.Facts ? `<div style="margin-top:6px;">${p.Facts}</div>` : ''}
          ${p.URL ? `<div style="margin-top:8px;"><a class="btn" href="${p.URL}" target="_blank" rel="noopener">Learn more →</a></div>` : ''}
        </div>`;
      popup.setLngLat([lng,lat]).setHTML(html).addTo(map);
    }
    function ensureHighlightLayer(){
      if (!map.getLayer('vineyard-selected-fill')) {
        map.addLayer({ id:'vineyard-selected-fill', type:'fill', source:'vineyard-polygons', 'source-layer': CONFIG.vector.sourceLayer, paint:{ 'fill-color':'#ffffff', 'fill-opacity':0.25 }, filter:['==', ['get','Name'], '___none___'] }, 'vineyard-outline');
      }
      if (!map.getLayer('vineyard-selected')) {
        map.addLayer({
          id: 'vineyard-selected',
          type: 'line',
          source: 'vineyard-polygons',
          'source-layer': CONFIG.vector.sourceLayer,
          paint: { 'line-color': '#ffffff', 'line-width': 2.5 },
          filter: ['==', ['get', 'Name'], '___none___']
        });
      }
    }
    function selectByName(name) {
      if (!name) return;
      // highlight polygon
      if (map.getSource('vineyard-polygons')) {
        ensureHighlightLayer();
        map.setFilter('vineyard-selected-fill', ['==', ['get','Name'], name]);
        map.setFilter('vineyard-selected', ['==', ['get','Name'], name]);
        const polys = map.querySourceFeatures('vineyard-polygons', { sourceLayer: CONFIG.vector.sourceLayer, filter: ['==', ['get','Name'], name] });
        if (polys && polys.length) {
          try { const b = turf.bbox(polys[0]); map.fitBounds([[b[0], b[1]], [b[2], b[3]]], { padding: 50 }); }
          catch(e){ /* fallback below */ }
        }
      }
      // fly to centroid
      const pt = (filteredPoints.length ? filteredPoints : allPoints).find(f => featureName(f) === name);
      if (pt) { flyTo(pt.geometry.coordinates); showPopupFor(pt); }
      highlightInList(name);
      history.replaceState(null, '', `#id=${encodeURIComponent(name)}`);
    }
    function fitAll(){
      const feats = filteredPoints.length ? filteredPoints : allPoints;
      if (!feats.length) return;
      const b = feats.reduce((bounds, ft) => bounds.extend(ft.geometry.coordinates), new mapboxgl.LngLatBounds(feats[0].geometry.coordinates, feats[0].geometry.coordinates));
      map.fitBounds(b, { padding: 50 });
    }
    function debounce(fn, ms=200){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; }
    const doFilter = debounce((q)=>{
      const term = q.trim().toLowerCase();
      filteredPoints = !term ? allPoints.slice() : allPoints.filter(f => {
        const p = f.properties || {};
        return [p.Name, p.SubAVA, p.Facts].some(v => (v||'').toLowerCase().includes(term));
      });
      buildLists(filteredPoints);
      if (map.getSource('vineyard-points')) map.getSource('vineyard-points').setData({ type:'FeatureCollection', features: filteredPoints });
    }, 160);

    // ===== Data plumbing =====
    async function fetchDatasetFeatures() {
      const base = 'https://api.mapbox.com/datasets/v1/';
      const url = base + CONFIG.dataset.username + '/' + CONFIG.dataset.id + '/features?access_token=' + encodeURIComponent(mapboxgl.accessToken);
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) throw new Error('Dataset fetch failed: ' + res.status);
      const fc = await res.json();
      if (!fc || !fc.features) throw new Error('No features in dataset.');

      if (fc.features.length) console.log('Sample dataset feature props:', fc.features[0].properties);

      const pts = [];
      for (const f of fc.features) {
        const p = f.properties || {};
        const name = (p.Name !== undefined && p.Name !== null) ? String(p.Name) : null;
        if (!name) continue;
        let center;
        if (f.geometry && f.geometry.type === 'Point') center = f.geometry.coordinates;
        else {
          try { center = turf.centroid(f).geometry.coordinates; } catch(e) { continue; }
        }
        pts.push({
          type:'Feature',
          properties: {
            Name: name,
            SubAVA: p.SubAVA || p.AVA || '',
            Facts: p.Facts || p.facts || '',
            URL: p.URL || p.url || ''
          },
          geometry: { type:'Point', coordinates: center }
        });
      }
      return { type:'FeatureCollection', features: pts };
    }

    async function addPointSourceAndLayers(geojson) {
      geojson.features = geojson.features.filter(f => f.properties && f.properties.Name);
      allPoints = geojson.features.slice();
      filteredPoints = allPoints.slice();
      buildLists(filteredPoints);

      if (map.getSource('vineyard-points')) map.removeSource('vineyard-points');
      ['clusters','cluster-count','vineyard-circles','vineyard-labels'].forEach(id => { if (map.getLayer(id)) map.removeLayer(id); });

      map.addSource('vineyard-points', {
        type:'geojson',
        data: geojson,
        cluster: true,
        clusterRadius: 50,
        clusterMaxZoom: 14
      });
      map.addLayer({
        id:'clusters', type:'circle', source:'vineyard-points', filter:['has','point_count'],
        paint:{ 'circle-color': ['step',['get','point_count'],'#42506B',5,'#5e6e90',15,'#7f8dae'], 'circle-radius': ['step',['get','point_count'],12,5,16,15,20], 'circle-stroke-color':'#0b0c10','circle-stroke-width':1.2 }
      });
      map.addLayer({
        id:'cluster-count', type:'symbol', source:'vineyard-points', filter:['has','point_count'],
        layout:{ 'text-field':['get','point_count_abbreviated'], 'text-size': 12 }, paint:{ 'text-color':'#eef2f7' }
      });
      map.addLayer({
        id:'vineyard-symbols', type:'symbol', source:'vineyard-points', filter:['!', ['has','point_count']],
        layout:{ 'icon-image':'marker-15', 'icon-size': 1.2, 'icon-allow-overlap': true },
        paint:{ 'icon-color': '#ffffff' }
      });
      map.addLayer({
        id:'vineyard-labels', type:'symbol', source:'vineyard-points', filter:['!', ['has','point_count']],
        minzoom: 12,
        layout:{ 'text-field':['get','Name'], 'text-size':12, 'text-offset':[0,1.1], 'text-anchor':'top' },
        paint:{ 'text-color':'#eef2f7', 'text-halo-color':'#0b0c10', 'text-halo-width':1.2 }
      });

      map.on('click','clusters',(e)=>{
        const f = map.queryRenderedFeatures(e.point, { layers:['clusters'] })[0];
        map.getSource('vineyard-points').getClusterExpansionZoom(f.properties.cluster_id, (err, zoom)=>{
          if (err) return; map.easeTo({ center: f.geometry.coordinates, zoom });
        });
      });
      map.on('click','vineyard-symbols',(e)=>{
        const f = e.features && e.features[0]; if (!f) return; selectByName(String(f.properties.Name));
      });
      ['clusters','vineyard-symbols'].forEach(l=>{ map.on('mouseenter', l, () => map.getCanvas().style.cursor='pointer'); map.on('mouseleave', l, () => map.getCanvas().style.cursor=''); });
    }

    // ===== Init =====
    map.on('load', async () => {
      // Polygons from tileset
      map.addSource('vineyard-polygons', { type:'vector', url: CONFIG.vector.url });
      map.addLayer({ id:'vineyard-fill', type:'fill', source:'vineyard-polygons', 'source-layer': CONFIG.vector.sourceLayer, paint:{ 'fill-color':'#c8a96a', 'fill-opacity':0.35 } });
      map.addLayer({ id:'vineyard-outline', type:'line', source:'vineyard-polygons', 'source-layer': CONFIG.vector.sourceLayer, paint:{ 'line-color':'#c8a96a', 'line-width':1.2 } });

      // Points/attributes from dataset
      try {
        let points = await fetchDatasetFeatures();
        points = groupPointsByName(points);
        await addPointSourceAndLayers(points);
        fitAll();
      } catch (e) {
        console.error(e);
        alert('Failed to load dataset features. Check your access token and dataset permissions.');
      }

      // Polygon click -> select by Name
      map.on('click','vineyard-fill', (e)=>{
        const f = e.features && e.features[0]; if (!f) return;
        const name = f.properties && f.properties.Name; if (name) selectByName(String(name));
      });
      map.on('mouseenter','vineyard-fill', () => map.getCanvas().style.cursor='pointer');
      map.on('mouseleave','vineyard-fill', () => map.getCanvas().style.cursor='');

      const m = location.hash.match(/id=([^&]+)/); if (m) setTimeout(()=>selectByName(decodeURIComponent(m[1])), 300);
    });

    // ===== UI events =====
    fitAllBtn.addEventListener('click', fitAll);
    refreshBtn.addEventListener('click', async () => {
      try { let pts = await fetchDatasetFeatures(); pts = groupPointsByName(pts); await addPointSourceAndLayers(pts); fitAll(); }
      catch(e) { console.error(e); alert('Refresh failed. See console.'); }
    });
    filterEl.addEventListener('input', (e)=> doFilter(e.target.value));

    // Sidebar collapse / expand
    let collapsed = false;
    function setCollapsed(val){
      collapsed = !!val;
      appEl.classList.toggle('sidebar-collapsed', collapsed);
      document.getElementById('sidebar').setAttribute('aria-hidden', collapsed ? 'true' : 'false');
      if (collapsed && window.innerWidth > 900) { fab.style.display = 'block'; } else { fab.style.display = 'none'; }
      setTimeout(()=>map.resize(), 60);
    }
    collapseBtn.addEventListener('click', () => setCollapsed(!collapsed));
    expandBtn.addEventListener('click', () => setCollapsed(false));
    window.addEventListener('resize', () => { if (window.innerWidth <= 900) fab.style.display='none'; else if (collapsed) fab.style.display='block'; });

    // Keyboard: S to toggle sidebar, / to focus filter
    document.addEventListener('keydown', (e)=>{
      if (e.key === '/' && document.activeElement !== filterEl) { e.preventDefault(); filterEl.focus(); }
      else if (e.key.toLowerCase() === 's' && window.innerWidth > 900) { setCollapsed(!collapsed); }
      else if (e.key === 'Escape') { popup.remove(); history.replaceState(null, '', location.pathname); const a=document.querySelector('.item.active'); if(a) a.classList.remove('active'); }
    });
  </script>
</body>
</html>
  <script>
    // ===== Config =====
    const CONFIG = {
      accessToken: 'pk.eyJ1IjoiZ3JhaGFtLWJjZWxsYXJzIiwiYSI6ImNsbmR1dWZiZjA3OXoyeWxpNTR4Z29wMjMifQ.Dw9ZRaGWdJkYUrFpML7XTw', // TODO: set this
      styleUrl: 'mapbox://styles/graham-bcellars/clogch2tt004201oi8i3jgyjy',
      vector: {
        url: 'mapbox://graham-bcellars.clnunbjdd0gcp2nn54qh84xr9-17y6g',
        sourceLayer: 'Vineyard-Sources'
      },
      dataset: {
        id: 'clnunbjdd0gcp2nn54qh84xr9',
        username: 'graham-bcellars' // adjust if needed
      },
      defaultCenter: [-122.37, 38.45],
      defaultZoom: 10,
      startPitch: 50
    };

    mapboxgl.accessToken = CONFIG.accessToken;
    const map = new mapboxgl.Map({
      container: 'map',
      style: CONFIG.styleUrl,
      center: CONFIG.defaultCenter,
      zoom: CONFIG.defaultZoom,
      pitch: CONFIG.startPitch,
      bearing: 0,
      cooperativeGestures: true,
      attributionControl: true
    });
    map.addControl(new mapboxgl.NavigationControl({showCompass:true}), 'top-right');
    map.addControl(new mapboxgl.FullscreenControl(), 'top-right');

    // ===== State =====
    const listEl = document.getElementById('list');
    const countEl = document.getElementById('count');
    const filterEl = document.getElementById('filter');
    const fitAllBtn = document.getElementById('fit-all');
    const refreshBtn = document.getElementById('refresh');
    const collapseBtn = document.getElementById('collapse');
    const appEl = document.querySelector('.app');
    const fab = document.getElementById('sidebar-fab');
    const expandBtn = document.getElementById('expand-sidebar');

    let allPoints = []; // centroids from dataset
    let filteredPoints = [];
    const popup = new mapboxgl.Popup({ closeButton: true, closeOnClick: true });

    // ===== Utilities =====
    function groupPointsByName(geojson){
      const groups = new Map();
      for (const f of geojson.features) {
        const name = f.properties && f.properties.Name;
        if (!name) continue;
        if (!groups.has(name)) {
          groups.set(name, { coords: [], props: f.properties });
        }
        groups.get(name).coords.push(f.geometry.coordinates);
      }
      const out = { type:'FeatureCollection', features: [] };
      for (const [name, rec] of groups.entries()) {
        // Average coordinates for a stable representative point
        const n = rec.coords.length;
        const avg = rec.coords.reduce((acc, c) => [acc[0]+c[0], acc[1]+c[1]], [0,0]).map(v => v/n);
        out.features.push({
          type:'Feature',
          properties: rec.props, // Name/SubAVA/Facts/URL from first feature
          geometry: { type:'Point', coordinates: avg }
        });
      }
      return out;
    }

    function featureName(f) { return (f.properties && f.properties.Name) ? String(f.properties.Name) : 'unknown'; }
    function announceCount(n) { countEl.textContent = `${n} vineyard${n===1?'':'s'}`; }
    function buildLists(items) {
      listEl.innerHTML = '';
      for (const f of items) {
        const p = f.properties || {};
        const li = document.createElement('button');
        li.className = 'item';
        li.type = 'button';
        li.dataset.id = p.Name;
        li.innerHTML = `
          <div class="name">${p.Name}</div>
          <div class="meta">${p.SubAVA || ''}</div>
          <div class="actions">
            <span class="btn" aria-hidden="true">Fly to</span>
            ${p.URL ? `<a class="btn" href="${p.URL}" target="_blank" rel="noopener" onclick="event.stopPropagation()">Learn more</a>` : ''}
          </div>`;
        li.addEventListener('click', () => selectByName(p.Name));
        listEl.appendChild(li);
      }
      announceCount(items.length);
    }
    function highlightInList(name) {
      document.querySelectorAll('.item').forEach(el => el.classList.toggle('active', el.dataset.id === name));
      const active = document.querySelector('.item.active'); if (active) active.scrollIntoView({block:'nearest', behavior:'smooth'});
    }
    function flyTo(lngLat){ map.flyTo({ center: lngLat, zoom: 15, pitch: 75, speed: 0.8, curve: 1.6, essential: true }); }); }
    function showPopupFor(f) {
      const p = f.properties || {};
      const [lng,lat] = f.geometry.coordinates;
      const html = `
        <div>
          <div style="font-weight:700; margin-bottom:4px;">${p.Name || 'Vineyard'}</div>
          ${p.SubAVA ? `<div style="font-size:12px; opacity:.8;">${p.SubAVA}</div>` : ''}
          ${p.Facts ? `<div style="margin-top:6px;">${p.Facts}</div>` : ''}
          ${p.URL ? `<div style="margin-top:8px;"><a class="btn" href="${p.URL}" target="_blank" rel="noopener">Learn more →</a></div>` : ''}
        </div>`;
      popup.setLngLat([lng,lat]).setHTML(html).addTo(map);
    }
    function ensureHighlightLayer(){
      if (!map.getLayer('vineyard-selected-fill')) {
        map.addLayer({ id:'vineyard-selected-fill', type:'fill', source:'vineyard-polygons', 'source-layer': CONFIG.vector.sourceLayer, paint:{ 'fill-color':'#ffffff', 'fill-opacity':0.25 }, filter:['==', ['get','Name'], '___none___'] }, 'vineyard-outline');
      }
      if (!map.getLayer('vineyard-selected')) {
        map.addLayer({
          id: 'vineyard-selected',
          type: 'line',
          source: 'vineyard-polygons',
          'source-layer': CONFIG.vector.sourceLayer,
          paint: { 'line-color': '#ffffff', 'line-width': 2.5 },
          filter: ['==', ['get', 'Name'], '___none___']
        });
      }
    }
    function selectByName(name) {
      if (!name) return;
      // highlight polygon
      if (map.getSource('vineyard-polygons')) {
        ensureHighlightLayer();
        map.setFilter('vineyard-selected-fill', ['==', ['get','Name'], name]);
        map.setFilter('vineyard-selected', ['==', ['get','Name'], name]);
        const polys = map.querySourceFeatures('vineyard-polygons', { sourceLayer: CONFIG.vector.sourceLayer, filter: ['==', ['get','Name'], name] });
        if (polys && polys.length) {
          try { const b = turf.bbox(polys[0]); map.fitBounds([[b[0], b[1]], [b[2], b[3]]], { padding: 50 }); }
          catch(e){ /* fallback below */ }
        }
      }
      // fly to centroid
      const pt = (filteredPoints.length ? filteredPoints : allPoints).find(f => featureName(f) === name);
      if (pt) { flyTo(pt.geometry.coordinates); showPopupFor(pt); }
      highlightInList(name);
      history.replaceState(null, '', `#id=${encodeURIComponent(name)}`);
    }
    function fitAll(){
      const feats = filteredPoints.length ? filteredPoints : allPoints;
      if (!feats.length) return;
      const b = feats.reduce((bounds, ft) => bounds.extend(ft.geometry.coordinates), new mapboxgl.LngLatBounds(feats[0].geometry.coordinates, feats[0].geometry.coordinates));
      map.fitBounds(b, { padding: 50 });
    }
    function debounce(fn, ms=200){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; }
    const doFilter = debounce((q)=>{
      const term = q.trim().toLowerCase();
      filteredPoints = !term ? allPoints.slice() : allPoints.filter(f => {
        const p = f.properties || {};
        return [p.Name, p.SubAVA, p.Facts].some(v => (v||'').toLowerCase().includes(term));
      });
      buildLists(filteredPoints);
      if (map.getSource('vineyard-points')) map.getSource('vineyard-points').setData({ type:'FeatureCollection', features: filteredPoints });
    }, 160);

    // ===== Data plumbing =====
    async function fetchDatasetFeatures() {
      const base = 'https://api.mapbox.com/datasets/v1/';
      const url = base + CONFIG.dataset.username + '/' + CONFIG.dataset.id + '/features?access_token=' + encodeURIComponent(mapboxgl.accessToken);
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) throw new Error('Dataset fetch failed: ' + res.status);
      const fc = await res.json();
      if (!fc || !fc.features) throw new Error('No features in dataset.');

      if (fc.features.length) console.log('Sample dataset feature props:', fc.features[0].properties);

      const pts = [];
      for (const f of fc.features) {
        const p = f.properties || {};
        const name = (p.Name !== undefined && p.Name !== null) ? String(p.Name) : null;
        if (!name) continue;
        let center;
        if (f.geometry && f.geometry.type === 'Point') center = f.geometry.coordinates;
        else {
          try { center = turf.centroid(f).geometry.coordinates; } catch(e) { continue; }
        }
        pts.push({
          type:'Feature',
          properties: {
            Name: name,
            SubAVA: p.SubAVA || p.AVA || '',
            Facts: p.Facts || p.facts || '',
            URL: p.URL || p.url || ''
          },
          geometry: { type:'Point', coordinates: center }
        });
      }
      return { type:'FeatureCollection', features: pts };
    }

    async function addPointSourceAndLayers(geojson) {
      geojson.features = geojson.features.filter(f => f.properties && f.properties.Name);
      allPoints = geojson.features.slice();
      filteredPoints = allPoints.slice();
      buildLists(filteredPoints);

      if (map.getSource('vineyard-points')) map.removeSource('vineyard-points');
      ['clusters','cluster-count','vineyard-circles','vineyard-labels'].forEach(id => { if (map.getLayer(id)) map.removeLayer(id); });

      map.addSource('vineyard-points', {
        type:'geojson',
        data: geojson,
        cluster: true,
        clusterRadius: 50,
        clusterMaxZoom: 14
      });
      map.addLayer({
        id:'clusters', type:'circle', source:'vineyard-points', filter:['has','point_count'],
        paint:{ 'circle-color': ['step',['get','point_count'],'#42506B',5,'#5e6e90',15,'#7f8dae'], 'circle-radius': ['step',['get','point_count'],12,5,16,15,20], 'circle-stroke-color':'#0b0c10','circle-stroke-width':1.2 }
      });
      map.addLayer({
        id:'cluster-count', type:'symbol', source:'vineyard-points', filter:['has','point_count'],
        layout:{ 'text-field':['get','point_count_abbreviated'], 'text-size': 12 }, paint:{ 'text-color':'#eef2f7' }
      });
      map.addLayer({
        id:'vineyard-symbols', type:'symbol', source:'vineyard-points', filter:['!', ['has','point_count']],
        layout:{ 'icon-image':'marker-15', 'icon-size': 1.2, 'icon-allow-overlap': true },
        paint:{ 'icon-color': '#ffffff' }
      });
      map.addLayer({
        id:'vineyard-labels', type:'symbol', source:'vineyard-points', filter:['!', ['has','point_count']],
        minzoom: 12,
        layout:{ 'text-field':['get','Name'], 'text-size':12, 'text-offset':[0,1.1], 'text-anchor':'top' },
        paint:{ 'text-color':'#eef2f7', 'text-halo-color':'#0b0c10', 'text-halo-width':1.2 }
      });

      map.on('click','clusters',(e)=>{
        const f = map.queryRenderedFeatures(e.point, { layers:['clusters'] })[0];
        map.getSource('vineyard-points').getClusterExpansionZoom(f.properties.cluster_id, (err, zoom)=>{
          if (err) return; map.easeTo({ center: f.geometry.coordinates, zoom });
        });
      });
      map.on('click','vineyard-symbols',(e)=>{
        const f = e.features && e.features[0]; if (!f) return; selectByName(String(f.properties.Name));
      });
      ['clusters','vineyard-symbols'].forEach(l=>{ map.on('mouseenter', l, () => map.getCanvas().style.cursor='pointer'); map.on('mouseleave', l, () => map.getCanvas().style.cursor=''); });
    }

    // ===== Init =====
    map.on('load', async () => {
      // Polygons from tileset
      map.addSource('vineyard-polygons', { type:'vector', url: CONFIG.vector.url });
      map.addLayer({ id:'vineyard-fill', type:'fill', source:'vineyard-polygons', 'source-layer': CONFIG.vector.sourceLayer, paint:{ 'fill-color':'#c8a96a', 'fill-opacity':0.35 } });
      map.addLayer({ id:'vineyard-outline', type:'line', source:'vineyard-polygons', 'source-layer': CONFIG.vector.sourceLayer, paint:{ 'line-color':'#c8a96a', 'line-width':1.2 } });

      // Points/attributes from dataset
      try {
        let points = await fetchDatasetFeatures();
        points = groupPointsByName(points);
        await addPointSourceAndLayers(points);
        fitAll();
      } catch (e) {
        console.error(e);
        alert('Failed to load dataset features. Check your access token and dataset permissions.');
      }

      // Polygon click -> select by Name
      map.on('click','vineyard-fill', (e)=>{
        const f = e.features && e.features[0]; if (!f) return;
        const name = f.properties && f.properties.Name; if (name) selectByName(String(name));
      });
      map.on('mouseenter','vineyard-fill', () => map.getCanvas().style.cursor='pointer');
      map.on('mouseleave','vineyard-fill', () => map.getCanvas().style.cursor='');

      const m = location.hash.match(/id=([^&]+)/); if (m) setTimeout(()=>selectByName(decodeURIComponent(m[1])), 300);
    });

    // ===== UI events =====
    fitAllBtn.addEventListener('click', fitAll);
    refreshBtn.addEventListener('click', async () => {
      try { let pts = await fetchDatasetFeatures(); pts = groupPointsByName(pts); await addPointSourceAndLayers(pts); fitAll(); }
      catch(e) { console.error(e); alert('Refresh failed. See console.'); }
    });
    filterEl.addEventListener('input', (e)=> doFilter(e.target.value));

    // Sidebar collapse / expand
    let collapsed = false;
    function setCollapsed(val){
      collapsed = !!val;
      appEl.classList.toggle('sidebar-collapsed', collapsed);
      document.getElementById('sidebar').setAttribute('aria-hidden', collapsed ? 'true' : 'false');
      if (collapsed && window.innerWidth > 900) { fab.style.display = 'block'; } else { fab.style.display = 'none'; }
      setTimeout(()=>map.resize(), 60);
    }
    collapseBtn.addEventListener('click', () => setCollapsed(!collapsed));
    expandBtn.addEventListener('click', () => setCollapsed(false));
    window.addEventListener('resize', () => { if (window.innerWidth <= 900) fab.style.display='none'; else if (collapsed) fab.style.display='block'; });

    // Keyboard: S to toggle sidebar, / to focus filter
    document.addEventListener('keydown', (e)=>{
      if (e.key === '/' && document.activeElement !== filterEl) { e.preventDefault(); filterEl.focus(); }
      else if (e.key.toLowerCase() === 's' && window.innerWidth > 900) { setCollapsed(!collapsed); }
      else if (e.key === 'Escape') { popup.remove(); history.replaceState(null, '', location.pathname); const a=document.querySelector('.item.active'); if(a) a.classList.remove('active'); }
    });
  </script>
</body>
</html>
  <script>
    // ===== Config =====
    const CONFIG = {
      accessToken: 'pk.eyJ1IjoiZ3JhaGFtLWJjZWxsYXJzIiwiYSI6ImNsbmR1dWZiZjA3OXoyeWxpNTR4Z29wMjMifQ.Dw9ZRaGWdJkYUrFpML7XTw', // TODO: set this
      styleUrl: 'mapbox://styles/graham-bcellars/clogch2tt004201oi8i3jgyjy',
      vector: {
        url: 'mapbox://graham-bcellars.clnunbjdd0gcp2nn54qh84xr9-17y6g',
        sourceLayer: 'vineyard-sources'
      },
      dataset: {
        id: 'clnunbjdd0gcp2nn54qh84xr9',
        username: 'graham-bcellars' // adjust if needed
      },
      defaultCenter: [-122.37, 38.45],
      defaultZoom: 10,
      startPitch: 50
    };

    mapboxgl.accessToken = CONFIG.accessToken;
    const map = new mapboxgl.Map({
      container: 'map',
      style: CONFIG.styleUrl,
      center: CONFIG.defaultCenter,
      zoom: CONFIG.defaultZoom,
      pitch: CONFIG.startPitch,
      bearing: 0,
      cooperativeGestures: true,
      attributionControl: true
    });
    map.addControl(new mapboxgl.NavigationControl({showCompass:true}), 'top-right');
    map.addControl(new mapboxgl.FullscreenControl(), 'top-right');

    // ===== State =====
    const listEl = document.getElementById('list');
    const countEl = document.getElementById('count');
    const filterEl = document.getElementById('filter');
    const fitAllBtn = document.getElementById('fit-all');
    const refreshBtn = document.getElementById('refresh');
    const collapseBtn = document.getElementById('collapse');
    const appEl = document.querySelector('.app');
    const fab = document.getElementById('sidebar-fab');
    const expandBtn = document.getElementById('expand-sidebar');

    let allPoints = []; // centroids from dataset
    let filteredPoints = [];
    const popup = new mapboxgl.Popup({ closeButton: true, closeOnClick: true });

    // ===== Utilities =====
    function featureName(f) { return (f.properties && f.properties.Name) ? String(f.properties.Name) : 'unknown'; }
    function announceCount(n) { countEl.textContent = `${n} vineyard${n===1?'':'s'}`; }
    function buildLists(items) {
      listEl.innerHTML = '';
      for (const f of items) {
        const p = f.properties || {};
        const li = document.createElement('button');
        li.className = 'item';
        li.type = 'button';
        li.dataset.id = p.Name;
        li.innerHTML = `
          <div class="name">${p.Name}</div>
          <div class="meta">${p.SubAVA || ''}</div>
          <div class="actions">
            <span class="btn" aria-hidden="true">Fly to</span>
            ${p.URL ? `<a class="btn" href="${p.URL}" target="_blank" rel="noopener" onclick="event.stopPropagation()">Learn more</a>` : ''}
          </div>`;
        li.addEventListener('click', () => selectByName(p.Name));
        listEl.appendChild(li);
      }
      announceCount(items.length);
    }
    function highlightInList(name) {
      document.querySelectorAll('.item').forEach(el => el.classList.toggle('active', el.dataset.id === name));
      const active = document.querySelector('.item.active'); if (active) active.scrollIntoView({block:'nearest', behavior:'smooth'});
    }
    function flyTo(lngLat, zoom=12.5) { map.flyTo({ center: lngLat, zoom, speed: 0.8, curve: 1.6, essential: true }); }
    function showPopupFor(f) {
      const p = f.properties || {};
      const [lng,lat] = f.geometry.coordinates;
      const html = `
        <div>
          <div style="font-weight:700; margin-bottom:4px;">${p.Name || 'Vineyard'}</div>
          ${p.SubAVA ? `<div style="font-size:12px; opacity:.8;">${p.SubAVA}</div>` : ''}
          ${p.Facts ? `<div style="margin-top:6px;">${p.Facts}</div>` : ''}
          ${p.URL ? `<div style="margin-top:8px;"><a class="btn" href="${p.URL}" target="_blank" rel="noopener">Learn more →</a></div>` : ''}
        </div>`;
      popup.setLngLat([lng,lat]).setHTML(html).addTo(map);
    }
    function ensureHighlightLayer(){
      if (!map.getLayer('vineyard-selected')) {
        map.addLayer({
          id: 'vineyard-selected',
          type: 'line',
          source: 'vineyard-polygons',
          'source-layer': CONFIG.vector.sourceLayer,
          paint: { 'line-color': '#ffffff', 'line-width': 2.5 },
          filter: ['==', ['get', 'Name'], '___none___']
        });
      }
    }
    function selectByName(name) {
      if (!name) return;
      // highlight polygon
      if (map.getSource('vineyard-polygons')) {
        ensureHighlightLayer();
        map.setFilter('vineyard-selected', ['==', ['get','Name'], name]);
        const polys = map.querySourceFeatures('vineyard-polygons', { sourceLayer: CONFIG.vector.sourceLayer, filter: ['==', ['get','Name'], name] });
        if (polys && polys.length) {
          try { const b = turf.bbox(polys[0]); map.fitBounds([[b[0], b[1]], [b[2], b[3]]], { padding: 50 }); }
          catch(e){ /* fallback below */ }
        }
      }
      // fly to centroid
      const pt = (filteredPoints.length ? filteredPoints : allPoints).find(f => featureName(f) === name);
      if (pt) { flyTo(pt.geometry.coordinates); showPopupFor(pt); }
      highlightInList(name);
      history.replaceState(null, '', `#id=${encodeURIComponent(name)}`);
    }
    function fitAll(){
      const feats = filteredPoints.length ? filteredPoints : allPoints;
      if (!feats.length) return;
      const b = feats.reduce((bounds, ft) => bounds.extend(ft.geometry.coordinates), new mapboxgl.LngLatBounds(feats[0].geometry.coordinates, feats[0].geometry.coordinates));
      map.fitBounds(b, { padding: 50 });
    }
    function debounce(fn, ms=200){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; }
    const doFilter = debounce((q)=>{
      const term = q.trim().toLowerCase();
      filteredPoints = !term ? allPoints.slice() : allPoints.filter(f => {
        const p = f.properties || {};
        return [p.Name, p.SubAVA, p.Facts].some(v => (v||'').toLowerCase().includes(term));
      });
      buildLists(filteredPoints);
      if (map.getSource('vineyard-points')) map.getSource('vineyard-points').setData({ type:'FeatureCollection', features: filteredPoints });
    }, 160);

    // ===== Data plumbing =====
    async function fetchDatasetFeatures() {
      const base = 'https://api.mapbox.com/datasets/v1/';
      const url = base + CONFIG.dataset.username + '/' + CONFIG.dataset.id + '/features?access_token=' + encodeURIComponent(mapboxgl.accessToken);
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) throw new Error('Dataset fetch failed: ' + res.status);
      const fc = await res.json();
      if (!fc || !fc.features) throw new Error('No features in dataset.');

      if (fc.features.length) console.log('Sample dataset feature props:', fc.features[0].properties);

      const pts = [];
      for (const f of fc.features) {
        const p = f.properties || {};
        const name = (p.Name !== undefined && p.Name !== null) ? String(p.Name) : null;
        if (!name) continue;
        let center;
        if (f.geometry && f.geometry.type === 'Point') center = f.geometry.coordinates;
        else {
          try { center = turf.centroid(f).geometry.coordinates; } catch(e) { continue; }
        }
        pts.push({
          type:'Feature',
          properties: {
            Name: name,
            SubAVA: p.SubAVA || p.AVA || '',
            Facts: p.Facts || p.facts || '',
            URL: p.URL || p.url || ''
          },
          geometry: { type:'Point', coordinates: center }
        });
      }
      return { type:'FeatureCollection', features: pts };
    }

    async function addPointSourceAndLayers(geojson) {
      geojson.features = geojson.features.filter(f => f.properties && f.properties.Name);
      allPoints = geojson.features.slice();
      filteredPoints = allPoints.slice();
      buildLists(filteredPoints);

      if (map.getSource('vineyard-points')) map.removeSource('vineyard-points');
      ['clusters','cluster-count','vineyard-circles','vineyard-labels'].forEach(id => { if (map.getLayer(id)) map.removeLayer(id); });

      map.addSource('vineyard-points', {
        type:'geojson',
        data: geojson,
        cluster: true,
        clusterRadius: 50,
        clusterMaxZoom: 14
      });
      map.addLayer({
        id:'clusters', type:'circle', source:'vineyard-points', filter:['has','point_count'],
        paint:{ 'circle-color': ['step',['get','point_count'],'#42506B',5,'#5e6e90',15,'#7f8dae'], 'circle-radius': ['step',['get','point_count'],12,5,16,15,20], 'circle-stroke-color':'#0b0c10','circle-stroke-width':1.2 }
      });
      map.addLayer({
        id:'cluster-count', type:'symbol', source:'vineyard-points', filter:['has','point_count'],
        layout:{ 'text-field':['get','point_count_abbreviated'], 'text-size': 12 }, paint:{ 'text-color':'#eef2f7' }
      });
      map.addLayer({
        id:'vineyard-circles', type:'circle', source:'vineyard-points', filter:['!', ['has','point_count']],
        paint:{ 'circle-radius': ['interpolate',['linear'],['zoom'],5,4,10,7,14,9], 'circle-color':'#c8a96a', 'circle-stroke-color':'#0b0c10', 'circle-stroke-width':1.2 }
      });
      map.addLayer({
        id:'vineyard-labels', type:'symbol', source:'vineyard-points', filter:['!', ['has','point_count']],
        layout:{ 'text-field':['get','Name'], 'text-size':12, 'text-offset':[0,1.1], 'text-anchor':'top' },
        paint:{ 'text-color':'#eef2f7', 'text-halo-color':'#0b0c10', 'text-halo-width':1.2 }
      });

      map.on('click','clusters',(e)=>{
        const f = map.queryRenderedFeatures(e.point, { layers:['clusters'] })[0];
        map.getSource('vineyard-points').getClusterExpansionZoom(f.properties.cluster_id, (err, zoom)=>{
          if (err) return; map.easeTo({ center: f.geometry.coordinates, zoom });
        });
      });
      map.on('click','vineyard-circles',(e)=>{
        const f = e.features && e.features[0]; if (!f) return; selectByName(String(f.properties.Name));
      });
      ['clusters','vineyard-circles'].forEach(l=>{ map.on('mouseenter', l, () => map.getCanvas().style.cursor='pointer'); map.on('mouseleave', l, () => map.getCanvas().style.cursor=''); });
    }

    // ===== Init =====
    map.on('load', async () => {
      // Polygons from tileset
      map.addSource('vineyard-polygons', { type:'vector', url: CONFIG.vector.url });
      map.addLayer({ id:'vineyard-fill', type:'fill', source:'vineyard-polygons', 'source-layer': CONFIG.vector.sourceLayer, paint:{ 'fill-color':'#c8a96a', 'fill-opacity':0.35 } });
      map.addLayer({ id:'vineyard-outline', type:'line', source:'vineyard-polygons', 'source-layer': CONFIG.vector.sourceLayer, paint:{ 'line-color':'#c8a96a', 'line-width':1.2 } });

      // Points/attributes from dataset
      try {
        const points = await fetchDatasetFeatures();
        await addPointSourceAndLayers(points);
        fitAll();
      } catch (e) {
        console.error(e);
        alert('Failed to load dataset features. Check your access token and dataset permissions.');
      }

      // Polygon click -> select by Name
      map.on('click','vineyard-fill', (e)=>{
        const f = e.features && e.features[0]; if (!f) return;
        const name = f.properties && f.properties.Name; if (name) selectByName(String(name));
      });
      map.on('mouseenter','vineyard-fill', () => map.getCanvas().style.cursor='pointer');
      map.on('mouseleave','vineyard-fill', () => map.getCanvas().style.cursor='');

      const m = location.hash.match(/id=([^&]+)/); if (m) setTimeout(()=>selectByName(decodeURIComponent(m[1])), 300);
    });

    // ===== UI events =====
    fitAllBtn.addEventListener('click', fitAll);
    refreshBtn.addEventListener('click', async () => {
      try { const pts = await fetchDatasetFeatures(); await addPointSourceAndLayers(pts); fitAll(); }
      catch(e) { console.error(e); alert('Refresh failed. See console.'); }
    });
    filterEl.addEventListener('input', (e)=> doFilter(e.target.value));

    // Sidebar collapse / expand
    let collapsed = false;
    function setCollapsed(val){
      collapsed = !!val;
      appEl.classList.toggle('sidebar-collapsed', collapsed);
      document.getElementById('sidebar').setAttribute('aria-hidden', collapsed ? 'true' : 'false');
      if (collapsed && window.innerWidth > 900) { fab.style.display = 'block'; } else { fab.style.display = 'none'; }
      setTimeout(()=>map.resize(), 60);
    }
    collapseBtn.addEventListener('click', () => setCollapsed(!collapsed));
    expandBtn.addEventListener('click', () => setCollapsed(false));
    window.addEventListener('resize', () => { if (window.innerWidth <= 900) fab.style.display='none'; else if (collapsed) fab.style.display='block'; });

    // Keyboard: S to toggle sidebar, / to focus filter
    document.addEventListener('keydown', (e)=>{
      if (e.key === '/' && document.activeElement !== filterEl) { e.preventDefault(); filterEl.focus(); }
      else if (e.key.toLowerCase() === 's' && window.innerWidth > 900) { setCollapsed(!collapsed); }
      else if (e.key === 'Escape') { popup.remove(); history.replaceState(null, '', location.pathname); const a=document.querySelector('.item.active'); if(a) a.classList.remove('active'); }
    });
  </script>
</body>
</html>
      box-shadow: var(--shadow);
    }
    .drawer {
      position: fixed; left: 0; right: 0; bottom: 0;
      height: 56px; /* closed height */
      background: var(--panel);
      border-top:1px solid var(--border);
      box-shadow: 0 -12px 30px rgba(0,0,0,.35);
      border-top-left-radius: 16px; border-top-right-radius: 16px;
      transform: translateY(100%);
      transition: transform .28s ease;
      z-index: 2;
      display:flex; flex-direction:column;
    }
    .drawer.open { transform: translateY(0); }
    .drawer .handle {
      display:flex; justify-content:center; padding: 8px; cursor:pointer;
    }
    .drawer .handle .pill {
      width: 48px; height: 5px; border-radius:99px; background:#273049;
    }
    .drawer .content {
      padding: 8px 12px 12px 12px;
      overflow:auto; flex:1; min-height: 40vh; max-height: 70vh;
    }
    .drawer .header { display:flex; align-items:center; justify-content:space-between; gap:10px; padding:0 4px 8px 4px; }
    .drawer .search { margin: 6px 0 10px; }
    .drawer .list { padding-bottom: max(10px, var(--safe-bottom)); }
    .hide-on-mobile { display: block; }
    .show-on-mobile { display: none; }
    .sidebar-toggle-fab {
      position: absolute;
      top: 12px;
      left: 12px;
      z-index: 5;
      display: none;
    }
    .sidebar-toggle-fab .btn {
      padding: 8px 12px;
      box-shadow: 0 6px 20px rgba(0,0,0,.35);
    }
    /* Map popup */
    .mapboxgl-popup { font: 14px/1.25 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    .mapboxgl-popup-content { border-radius: 12px; padding: 10px 12px; background:#0f1219; color: var(--text); border:1px solid #273049; text-align:left; }
    .mapboxgl-popup-close-button { color: var(--text); }

    /* Tablet/desktop: sidebar + map */
    @media (max-width: 900px) {
      .app { grid-template-columns: 1fr; }
      .sidebar { display:none; }
      .hide-on-mobile { display:none; }
      .show-on-mobile { display:block; }
    }
  </style>
</head>
<body>
  <div class="app">
    <aside class="sidebar" aria-label="Vineyard navigation" id="sidebar">
      <div class="brand">
        <h1>Vineyards</h1>
        <div class="controls">
          <button id="fit-all" class="btn" title="Zoom to all vineyards">Fit all</button>
          <button id="refresh" class="btn secondary" title="Rebuild list from tiles">Refresh list</button>
          <button id="collapse" class="btn secondary" title="Hide/show sidebar">Collapse</button>
        </div>
      </div>
      <div class="search">
        <input id="filter" type="search" placeholder="Filter vineyards… (name, AVA, notes)" aria-label="Filter vineyards" />
      </div>
      <div class="count" id="count" aria-live="polite">—</div>
      <div class="list" id="list" role="list"></div>
    </aside>

    <div id="map" role="region" aria-label="Map of vineyard locations">
      <div class="sidebar-toggle-fab" id="sidebar-fab">
        <button class="btn" id="expand-sidebar" title="Show sidebar">Show sidebar</button>
      </div>
    </div>

    <!-- Mobile drawer -->
    <div class="drawer-toggle show-on-mobile">
      <button class="drawer-button" id="drawer-button" aria-expanded="false" aria-controls="mobile-drawer">Vineyards</button>
    </div>
    <section class="drawer" id="mobile-drawer" aria-label="Vineyard list drawer">
      <div class="handle" id="drawer-handle" aria-hidden="true"><div class="pill"></div></div>
      <div class="content">
        <div class="header">
          <div class="count" id="m-count">—</div>
          <div class="controls"><button id="m-fit-all" class="btn">Fit all</button></div>
        </div>
        <div class="search"><input id="m-filter" type="search" placeholder="Search vineyards…" aria-label="Search vineyards" /></div>
        <div class="list" id="m-list" role="list"></div>
      </div>
    </section>
  </div>

  <script>
    // =========================
    // Configuration
    // =========================
    const CONFIG = {
      accessToken: 'pk.eyJ1IjoiZ3JhaGFtLWJjZWxsYXJzIiwiYSI6ImNsbmR1dWZiZjA3OXoyeWxpNTR4Z29wMjMifQ.Dw9ZRaGWdJkYUrFpML7XTw', // TODO: replace
      styleUrl: 'mapbox://styles/graham-bcellars/clogch2tt004201oi8i3jgyjy', // TODO: replace
      // Option A: polygon vector tileset for vineyard boundaries (set both or leave sourceLayer empty to skip)
      vector: { url: 'mapbox://graham-bcellars.clnunbjdd0gcp2nn54qh84xr9-79q6y', sourceLayer: 'vineyard-map' }, // TODO: set source-layer or leave '' to skip
      // Option B: points GeoJSON (recommended if you don't have a polygon tileset)
      pointsGeoJSON: null, // Or set to a URL string like '/data/vineyards_points.geojson'
      // UI
      defaultCenter: [-122.37, 38.45],
      defaultZoom: 10
    };

    // =========================
    // Map init
    // =========================
    mapboxgl.accessToken = CONFIG.accessToken;
    const map = new mapboxgl.Map({
      container: 'map',
      style: CONFIG.styleUrl,
      center: CONFIG.defaultCenter,
      zoom: CONFIG.defaultZoom,
      cooperativeGestures: true,
      attributionControl: true,
      pitch: 50,
      maxPitch: 80
    });
    map.addControl(new mapboxgl.NavigationControl({showCompass: true}), 'top-right');
    map.addControl(new mapboxgl.FullscreenControl(), 'top-right');
    map.addControl(new mapboxgl.GeolocateControl({ positionOptions: { enableHighAccuracy: true }, trackUserLocation: false }), 'top-right');

    // =========================
    // State
    // =========================
    const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const listEl = document.getElementById('list');
    const countEl = document.getElementById('count');
    const filterEl = document.getElementById('filter');
    const mListEl = document.getElementById('m-list');
    const mCountEl = document.getElementById('m-count');
    const mFilterEl = document.getElementById('m-filter');
    const drawerButton = document.getElementById('drawer-button');
    const drawerEl = document.getElementById('mobile-drawer');
    const fitAllBtn = document.getElementById('fit-all');
    const mFitAllBtn = document.getElementById('m-fit-all');
    const collapseBtn = document.getElementById('collapse');
    let allPoints = [];         // Array<Feature<Point>>
    let filteredPoints = [];    // Array<Feature<Point>>
    const popup = new mapboxgl.Popup({ closeButton: true, closeOnClick: true });

    // Demo fallback data if you haven't wired in a tileset/geojson yet
    const demo = {
      type: 'FeatureCollection',
      features: [
        { type: 'Feature', properties: { id: 'to-kalon', Name: 'To Kalon Vineyard', SubAVA: 'Oakville AVA, Napa Valley', Facts: 'Historic site; well-drained alluvial fans; Cabernet Sauvignon', URL: 'https://example.com/to-kalon' }, geometry: { type: 'Point', coordinates: [-122.4139, 38.4387] } },
        { type: 'Feature', properties: { id: 'stagecoach', Name: 'Stagecoach Vineyard', SubAVA: 'Atlas Peak AVA, Napa Valley', Facts: 'Volcanic tuff/red soils; mountain fruit', URL: 'https://example.com/stagecoach' }, geometry: { type: 'Point', coordinates: [-122.239, 38.396] } },
        { type: 'Feature', properties: { id: 'sangiacomo', Name: 'Sangiacomo Vineyard', SubAVA: 'Carneros AVA, Sonoma', Facts: 'Cool-climate; Chardonnay & Pinot Noir', URL: 'https://example.com/sangiacomo' }, geometry: { type: 'Point', coordinates: [-122.442, 38.240] } }
      ]
    };

    // =========================
    // Helpers
    // Selected polygon highlight
    function ensureHighlightLayer(){
      if (!map.getLayer('vineyard-selected')) {
        map.addLayer({
          id: 'vineyard-selected',
          type: 'line',
          source: 'vineyard-polygons',
          'source-layer': CONFIG.vector.sourceLayer,
          paint: { 'line-color': '#ffffff', 'line-width': 2.5 },
          filter: ['==', ['get', 'Name'], '___none___']
        });
      }
    }
    function selectByName(name, {updateHash=true}={}){
      if (!name) return;
      // Highlight polygon if present
      if (map.getSource('vineyard-polygons')) {
        ensureHighlightLayer();
        map.setFilter('vineyard-selected', ['==', ['get','Name'], name]);
        // Fit to polygon bounds if we can find it
        const polys = map.querySourceFeatures('vineyard-polygons', { sourceLayer: CONFIG.vector.sourceLayer, filter: ['==', ['get','Name'], name] });
        if (polys && polys.length) {
          try {
            const b = turf.bbox(polys[0]);
            map.fitBounds([[b[0], b[1]], [b[2], b[3]]], { padding: 50 });
          } catch(e){ /* fall through to point */ }
        }
      }
      // Fallback to flying to centroid point
      const f = (allPoints || []).find(ft => featureId(ft) === name) || (filteredPoints || []).find(ft => featureId(ft) === name);
      if (f) { flyTo(f.geometry.coordinates); showPopupFor(f); }
      highlightInLists(name);
      if (updateHash) history.replaceState(null, '', `#id=${encodeURIComponent(name)}`);
    }

    // =========================
    function announceCount(listTarget, n){
      listTarget.textContent = `${n} vineyard${n===1?'':'s'}`;
    }
    function featureId(f){
      const p = f.properties || {};
      return (p.Name !== undefined && p.Name !== null) ? String(p.Name) : 'unknown';
    }
    function toPointFromPolygon(poly){
      const center = turf.center(poly).geometry.coordinates;
      const p = poly.properties || {};
      return {
        type:'Feature',
        properties: {
          id: featureId(poly),
          Name: p.Name || p.name || 'Unknown vineyard',
          SubAVA: p.SubAVA || p.AVA || '',
          Facts: p.Facts || p.facts || '',
          URL: p.URL || p.url || ''
        },
        geometry: { type:'Point', coordinates: center }
      };
    }
    function flyTo(lngLat, zoom=12.5){
      if (prefersReduced) {
        map.easeTo({ center: lngLat, zoom, duration: 0 });
      } else {
        map.flyTo({ center: lngLat, zoom, speed: 0.8, curve: 1.6, essential: true });
      }
    }
    function showPopupFor(f){
      const p = f.properties || {};
      const [lng,lat] = f.geometry.coordinates;
      const gm = `https://www.google.com/maps?q=${lat},${lng}`;
      const html = `
        <div>
          <div style="font-weight:700; margin-bottom:4px;">${p.Name || 'Vineyard'}</div>
          ${p.SubAVA ? `<div style="font-size:12px; opacity:.8;">${p.SubAVA}</div>` : ''}
          ${p.Facts ? `<div style="margin-top:6px;">${p.Facts}</div>` : ''}
          <div style="margin-top:8px; display:flex; gap:10px; flex-wrap:wrap">
            ${p.URL ? `<a class="btn" href="${p.URL}" target="_blank" rel="noopener">Learn more →</a>` : ''}
            <a class="btn secondary" href="${gm}" target="_blank" rel="noopener">Open in Maps</a>
          </div>
        </div>`;
      popup.setLngLat([lng,lat]).setHTML(html).addTo(map);
    }
    function selectFeature(id, {updateHash=true}={}){
      // Deprecated: keep for safety, redirect to Name-based selection
      return selectByName(id, {updateHash});
    }

    function UNUSED__old_selectFeature(id, {updateHash=true}={}){
      const f = (allPoints || []).find(ft => featureId(ft) === id) || (filteredPoints || []).find(ft => featureId(ft) === id);
      if (!f) return;
      const [lng,lat] = f.geometry.coordinates;
      flyTo([lng,lat]);
      showPopupFor(f);
      highlightInLists(id);
      if (updateHash) {
        history.replaceState(null, '', `#id=${encodeURIComponent(id)}`);
      }
    }
    function highlightInLists(id){
      for (const el of document.querySelectorAll('.item')) {
        el.classList.toggle('active', el.dataset.id === id);
      }
      const active = document.querySelector('.item.active');
      if (active) active.scrollIntoView({block:'nearest', behavior:'smooth'});
    }
    function fitAll(){
      const feats = (filteredPoints.length ? filteredPoints : allPoints);
      if (!feats.length) return;
      const b = feats.reduce((bounds, ft) => bounds.extend(ft.geometry.coordinates),
        new mapboxgl.LngLatBounds(feats[0].geometry.coordinates, feats[0].geometry.coordinates));
      map.fitBounds(b, { padding: {top:50,right:50,bottom:50,left:50} });
    }
    function buildLists(items){
      const mkItem = (f) => {
        const p = f.properties;
        const li = document.createElement('button');
        li.className = 'item';
        li.type = 'button';
        li.setAttribute('role','listitem');
        const id = featureId(f);
        li.dataset.id = String(p.Name);
        li.innerHTML = `
          <div class="name">${p.Name}</div>
          <div class="meta">${p.SubAVA || ''}</div>
          <div class="actions">
            <span class="btn" aria-hidden="true">Fly to</span>
            ${p.URL ? `<a class="btn" href="${p.URL}" target="_blank" rel="noopener" onclick="event.stopPropagation()">Learn more</a>` : ''}
          </div>
        `;
        li.addEventListener('click', () => selectByName(id));
        return li;
      };
      // Desktop list
      listEl.innerHTML = '';
      items.forEach(f => listEl.appendChild(mkItem(f)));
      announceCount(countEl, items.length);
      // Mobile list
      mListEl.innerHTML = '';
      items.forEach(f => mListEl.appendChild(mkItem(f)));
      announceCount(mCountEl, items.length);
    }
    function debounce(fn, ms=200){
      let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
    }
    const doFilter = debounce((q) => {
      const term = q.trim().toLowerCase();
      filteredPoints = !term ? allPoints.slice() : allPoints.filter(f => {
        const p = f.properties;
        return [p.Name, p.SubAVA, p.Facts].some(v => (v||'').toLowerCase().includes(term));
      });
      buildLists(filteredPoints);
      // Update map point source to filtered features
      if (map.getSource('vineyard-points')) {
        map.getSource('vineyard-points').setData({ type:'FeatureCollection', features: filteredPoints });
      }
    }, 160);

    // =========================
    // Sources & Layers
    // =========================
    map.on('load', async () => {
      // Option A: Vector polygons -> derive centroids for points
      
      if (CONFIG.vector.url && CONFIG.vector.sourceLayer) {
        map.addSource('vineyard-polygons', { type:'vector', url: CONFIG.vector.url });
        map.addLayer({ id:'vineyard-fill', type:'fill', source:'vineyard-polygons', 'source-layer': CONFIG.vector.sourceLayer, paint:{ 'fill-color':'#c8a96a', 'fill-opacity':0.35 } });
        map.addLayer({ id:'vineyard-outline', type:'line', source:'vineyard-polygons', 'source-layer': CONFIG.vector.sourceLayer, paint:{ 'line-color':'#c8a96a', 'line-width': 1.2 } });

        // Load a broad view to ensure tiles get cached, then harvest features from the source.
        await preloadTilesAndBuildCentroids();
      }
 else if (typeof CONFIG.pointsGeoJSON === 'string') {
        try {
          const res = await fetch(CONFIG.pointsGeoJSON, { cache: 'no-store' });
          const data = await res.json();
          await addPointSourceAndLayers(data);
        } catch (e) {
          console.warn('Failed to fetch points GeoJSON. Falling back to demo.', e);
          await addPointSourceAndLayers(demo);
        }
      }
      // Fallback demo
      else {
        await addPointSourceAndLayers(demo);
      }

      // Polygon click also selects
      if (map.getLayer('vineyard-fill')) {
        map.on('click', 'vineyard-fill', (e) => {
          const f = e.features && e.features[0];
          if (!f) return;
          selectByName(featureId(f));
        });
        map.on('mouseenter', 'vineyard-fill', () => map.getCanvas().style.cursor = 'pointer');
        map.on('mouseleave', 'vineyard-fill', () => map.getCanvas().style.cursor = '');
      }

      // Deep link: #id=...
      const m = location.hash.match(/id=([^&]+)/);
      if (m) {
        const id = decodeURIComponent(m[1]);
        // allow sources to finish
        setTimeout(() => selectFeature(id, {updateHash:false}), 300);
      } else {
        fitAll();
      }
    });

    async function addPointSourceAndLayers(geojson){
      // Normalize properties so UI is consistent
      geojson.features.forEach(f => {
        const p = f.properties || {};
        f.properties = {
          id: featureId(f),
          Name: p.Name || p.name || 'Unknown vineyard',
          SubAVA: p.SubAVA || p.AVA || '',
          Facts: p.Facts || p.facts || '',
          URL: p.URL || p.url || ''
        };
      });
      allPoints = geojson.features.slice();
      filteredPoints = allPoints.slice();
      buildLists(filteredPoints);

      // Clustered source (great for many vineyards)
      map.addSource('vineyard-points', {
        type: 'geojson',
        data: { type:'FeatureCollection', features: filteredPoints },
        cluster: true,
        clusterRadius: 50,
        clusterMaxZoom: 14
      });

      // Clusters
      map.addLayer({
        id: 'clusters',
        type: 'circle',
        source: 'vineyard-points',
        filter: ['has', 'point_count'],
        paint: {
          'circle-color': [
            'step', ['get', 'point_count'],
            '#42506B', 5, '#5e6e90', 15, '#7f8dae'
          ],
          'circle-radius': [
            'step', ['get', 'point_count'],
            12, 5, 16, 15, 20
          ],
          'circle-stroke-color': '#0b0c10',
          'circle-stroke-width': 1.2
        }
      });
      map.addLayer({
        id: 'cluster-count',
        type: 'symbol',
        source: 'vineyard-points',
        filter: ['has', 'point_count'],
        layout: { 'text-field': ['get','point_count_abbreviated'], 'text-size': 12 },
        paint: { 'text-color': '#eef2f7' }
      });

      // Unclustered points
      map.addLayer({
        id: 'vineyard-circles',
        type: 'circle',
        source: 'vineyard-points',
        filter: ['!', ['has', 'point_count']],
        paint: {
          'circle-radius': ['interpolate', ['linear'], ['zoom'], 5, 4, 10, 7, 14, 9],
          'circle-color': '#c8a96a',
          'circle-stroke-color': '#0b0c10',
          'circle-stroke-width': 1.2
        }
      });
      map.addLayer({
        id: 'vineyard-labels',
        type: 'symbol',
        source: 'vineyard-points',
        filter: ['!', ['has', 'point_count']],
        layout: {
          'text-field': ['get', 'Name'],
          'text-size': 12,
          'text-offset': [0, 1.1],
          'text-anchor': 'top'
        },
        paint: {
          'text-color': '#eef2f7',
          'text-halo-color': '#0b0c10',
          'text-halo-width': 1.2
        }
      });

      // Interactivity
      map.on('click', 'clusters', function (e) {
        const features = map.queryRenderedFeatures(e.point, { layers: ['clusters'] });
        const clusterId = features[0].properties.cluster_id;
        map.getSource('vineyard-points').getClusterExpansionZoom(clusterId, function (err, zoom) {
          if (err) return;
          map.easeTo({ center: features[0].geometry.coordinates, zoom });
        });
      });
      map.on('click', 'vineyard-circles', (e) => {
        const f = e.features && e.features[0];
        if (!f) return;
        selectByName(featureId(f));
      });
      ['clusters','vineyard-circles'].forEach(l => {
        map.on('mouseenter', l, () => map.getCanvas().style.cursor = 'pointer');
        map.on('mouseleave', l, () => map.getCanvas().style.cursor = '');
      });
    }

    
    async function preloadTilesAndBuildCentroids(){
      // Save current view
      const prev = { center: map.getCenter(), zoom: map.getZoom(), bearing: map.getBearing(), pitch: map.getPitch() };

      // Zoom out to load a wider swath of tiles around the default center
      map.easeTo({ center: CONFIG.defaultCenter, zoom: Math.min(9, prev.zoom), duration: 0 });
      await map.once('idle');

      // Harvest centroids from vector source tiles
      const centroidFC = harvestVectorCentroids();
      if (centroidFC.features.length === 0) {
        console.warn('No vector features found. Double-check the source-layer name.');
      }
      await addPointSourceAndLayers(centroidFC.features.length ? centroidFC : demo);

      // Restore previous view
      map.easeTo({ center: prev.center, zoom: prev.zoom, bearing: prev.bearing, pitch: prev.pitch, duration: 0 });
    }

    function harvestVectorCentroids(){
      const feats = map.querySourceFeatures('vineyard-polygons', { sourceLayer: CONFIG.vector.sourceLayer }) || [];
      const uniq = new Map();
      for (const f of feats) {
        const id = featureId(f);
        if (!uniq.has(id)) {
          uniq.set(id, toPointFromPolygon(f));
        }
      }
      return { type: 'FeatureCollection', features: Array.from(uniq.values()) };
    }

    // =========================
    // UI wiring
    // =========================
    fitAllBtn.addEventListener('click', fitAll);
    mFitAllBtn.addEventListener('click', fitAll);
    document.getElementById('refresh').addEventListener('click', preloadTilesAndBuildCentroids);
    filterEl.addEventListener('input', (e)=> doFilter(e.target.value));
    mFilterEl.addEventListener('input', (e)=> doFilter(e.target.value));

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.key === '/' && document.activeElement !== filterEl && document.activeElement !== mFilterEl) {
        e.preventDefault();
        (window.innerWidth <= 900 ? mFilterEl : filterEl).focus();
      } else if (e.key.toLowerCase() === 'f') {
        fitAll();
      } else if (e.key.toLowerCase() === 's' && window.innerWidth > 900) {
        setCollapsed(!collapsed);
      } else if (e.key === 'Escape') {
        popup.remove();
        history.replaceState(null, '', location.pathname);
        const active = document.querySelector('.item.active'); if (active) active.classList.remove('active');
      }
    });

    // Sidebar collapse (desktop)
    const appEl = document.querySelector('.app');
    let collapsed = false;
    const fab = document.getElementById('sidebar-fab');
    const expandBtn = document.getElementById('expand-sidebar');
    collapseBtn.setAttribute('aria-expanded','true');
    function setCollapsed(val){
      collapsed = !!val;
      appEl.classList.toggle('sidebar-collapsed', collapsed);
      document.getElementById('sidebar').setAttribute('aria-hidden', collapsed ? 'true' : 'false');
      collapseBtn.textContent = collapsed ? 'Expand' : 'Collapse';
      collapseBtn.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
      // Show floating reopen button only when collapsed and on desktop widths
      if (collapsed && window.innerWidth > 900) { fab.style.display = 'block'; } else { fab.style.display = 'none'; }
      setTimeout(() => map.resize(), 60);
    }
    collapseBtn.addEventListener('click', () => setCollapsed(!collapsed));
    expandBtn.addEventListener('click', () => setCollapsed(false));
    window.addEventListener('resize', () => { if (window.innerWidth <= 900) fab.style.display = 'none'; else if (collapsed) fab.style.display = 'block'; });

    // Drawer controls (mobile)
    function setDrawerOpen(open) {
      drawerEl.classList.toggle('open', open);
      drawerButton.setAttribute('aria-expanded', open ? 'true' : 'false');
    }
    drawerButton.addEventListener('click', () => {
      const open = !drawerEl.classList.contains('open');
      setDrawerOpen(open);
      if (open) mFilterEl.focus();
    });
    document.getElementById('drawer-handle').addEventListener('click', () => setDrawerOpen(!drawerEl.classList.contains('open')));

    // Clicking map on mobile closes the drawer
    map.on('click', () => { if (window.innerWidth <= 900) setDrawerOpen(false); });

  </script>
</body>
</html>
      box-shadow: var(--shadow);
    }
    .drawer {
      position: fixed; left: 0; right: 0; bottom: 0;
      height: 56px; /* closed height */
      background: var(--panel);
      border-top:1px solid var(--border);
      box-shadow: 0 -12px 30px rgba(0,0,0,.35);
      border-top-left-radius: 16px; border-top-right-radius: 16px;
      transform: translateY(100%);
      transition: transform .28s ease;
      z-index: 2;
      display:flex; flex-direction:column;
    }
    .drawer.open { transform: translateY(0); }
    .drawer .handle {
      display:flex; justify-content:center; padding: 8px; cursor:pointer;
    }
    .drawer .handle .pill {
      width: 48px; height: 5px; border-radius:99px; background:#273049;
    }
    .drawer .content {
      padding: 8px 12px 12px 12px;
      overflow:auto; flex:1; min-height: 40vh; max-height: 70vh;
    }
    .drawer .header { display:flex; align-items:center; justify-content:space-between; gap:10px; padding:0 4px 8px 4px; }
    .drawer .search { margin: 6px 0 10px; }
    .drawer .list { padding-bottom: max(10px, var(--safe-bottom)); }
    .hide-on-mobile { display: block; }
    .show-on-mobile { display: none; }
    .sidebar-toggle-fab {
      position: absolute;
      top: 12px;
      left: 12px;
      z-index: 5;
      display: none;
    }
    .sidebar-toggle-fab .btn {
      padding: 8px 12px;
      box-shadow: 0 6px 20px rgba(0,0,0,.35);
    }
    /* Map popup */
    .mapboxgl-popup { font: 14px/1.25 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    .mapboxgl-popup-content { border-radius: 12px; padding: 10px 12px; background:#0f1219; color: var(--text); border:1px solid #273049; text-align:left; }
    .mapboxgl-popup-close-button { color: var(--text); }

    /* Tablet/desktop: sidebar + map */
    @media (max-width: 900px) {
      .app { grid-template-columns: 1fr; }
      .sidebar { display:none; }
      .hide-on-mobile { display:none; }
      .show-on-mobile { display:block; }
    }
  </style>
</head>
<body>
  <div class="app">
    <aside class="sidebar" aria-label="Vineyard navigation" id="sidebar">
      <div class="brand">
        <h1>Vineyard Sources</h1>
        <div class="controls">
          <button id="fit-all" class="btn" title="Zoom to all vineyards">Fit all</button>
          <button id="refresh" class="btn secondary" title="Rebuild list from tiles">Refresh list</button>
          <button id="collapse" class="btn secondary" title="Hide/show sidebar">Collapse</button>
        </div>
      </div>
      <div class="search">
        <input id="filter" type="search" placeholder="Filter vineyards… (name, AVA, notes)" aria-label="Filter vineyards" />
      </div>
      <div class="count" id="count" aria-live="polite">—</div>
      <div class="list" id="list" role="list"></div>
    </aside>

    <div id="map" role="region" aria-label="Map of vineyard locations">
      <div class="sidebar-toggle-fab" id="sidebar-fab">
        <button class="btn" id="expand-sidebar" title="Show sidebar">Show sidebar</button>
      </div>
    </div>

    <!-- Mobile drawer -->
    <div class="drawer-toggle show-on-mobile">
      <button class="drawer-button" id="drawer-button" aria-expanded="false" aria-controls="mobile-drawer">Vineyards</button>
    </div>
    <section class="drawer" id="mobile-drawer" aria-label="Vineyard list drawer">
      <div class="handle" id="drawer-handle" aria-hidden="true"><div class="pill"></div></div>
      <div class="content">
        <div class="header">
          <div class="count" id="m-count">—</div>
          <div class="controls"><button id="m-fit-all" class="btn">Fit all</button></div>
        </div>
        <div class="search"><input id="m-filter" type="search" placeholder="Search vineyards…" aria-label="Search vineyards" /></div>
        <div class="list" id="m-list" role="list"></div>
      </div>
    </section>
  </div>

  <script>
    // =========================
    // Configuration
    // =========================
    const CONFIG = {
      accessToken: 'pk.eyJ1IjoiZ3JhaGFtLWJjZWxsYXJzIiwiYSI6ImNsbmR1dWZiZjA3OXoyeWxpNTR4Z29wMjMifQ.Dw9ZRaGWdJkYUrFpML7XTw', // TODO: replace
      styleUrl: 'mapbox://styles/graham-bcellars/clogch2tt004201oi8i3jgyjy', // TODO: replace
      // Option A: polygon vector tileset for vineyard boundaries (set both or leave sourceLayer empty to skip)
      vector: { url: 'mapbox://graham-bcellars.clnunbjdd0gcp2nn54qh84xr9-79q6y', sourceLayer: 'vineyard-map' }, // TODO: set source-layer or leave '' to skip
      // Option B: points GeoJSON (recommended if you don't have a polygon tileset)
      pointsGeoJSON: null, // Or set to a URL string like '/data/vineyards_points.geojson'
      // UI
      defaultCenter: [-122.37, 38.45],
      defaultZoom: 10
    };

    // =========================
    // Map init
    // =========================
    mapboxgl.accessToken = CONFIG.accessToken;
    const map = new mapboxgl.Map({
      container: 'map',
      style: CONFIG.styleUrl,
      center: CONFIG.defaultCenter,
      zoom: CONFIG.defaultZoom,
      cooperativeGestures: true,
      attributionControl: true,
      pitch: 50,
      maxPitch: 80
    });
    map.addControl(new mapboxgl.NavigationControl({showCompass: true}), 'top-right');
    map.addControl(new mapboxgl.FullscreenControl(), 'top-right');
    map.addControl(new mapboxgl.GeolocateControl({ positionOptions: { enableHighAccuracy: true }, trackUserLocation: false }), 'top-right');

    // =========================
    // State
    // =========================
    const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const listEl = document.getElementById('list');
    const countEl = document.getElementById('count');
    const filterEl = document.getElementById('filter');
    const mListEl = document.getElementById('m-list');
    const mCountEl = document.getElementById('m-count');
    const mFilterEl = document.getElementById('m-filter');
    const drawerButton = document.getElementById('drawer-button');
    const drawerEl = document.getElementById('mobile-drawer');
    const fitAllBtn = document.getElementById('fit-all');
    const mFitAllBtn = document.getElementById('m-fit-all');
    const collapseBtn = document.getElementById('collapse');
    let allPoints = [];         // Array<Feature<Point>>
    let filteredPoints = [];    // Array<Feature<Point>>
    const popup = new mapboxgl.Popup({ closeButton: true, closeOnClick: true });

    // Demo fallback data if you haven't wired in a tileset/geojson yet
    const demo = {
      type: 'FeatureCollection',
      features: [
        { type: 'Feature', properties: { id: 'to-kalon', Name: 'To Kalon Vineyard', SubAVA: 'Oakville AVA, Napa Valley', Facts: 'Historic site; well-drained alluvial fans; Cabernet Sauvignon', URL: 'https://example.com/to-kalon' }, geometry: { type: 'Point', coordinates: [-122.4139, 38.4387] } },
        { type: 'Feature', properties: { id: 'stagecoach', Name: 'Stagecoach Vineyard', SubAVA: 'Atlas Peak AVA, Napa Valley', Facts: 'Volcanic tuff/red soils; mountain fruit', URL: 'https://example.com/stagecoach' }, geometry: { type: 'Point', coordinates: [-122.239, 38.396] } },
        { type: 'Feature', properties: { id: 'sangiacomo', Name: 'Sangiacomo Vineyard', SubAVA: 'Carneros AVA, Sonoma', Facts: 'Cool-climate; Chardonnay & Pinot Noir', URL: 'https://example.com/sangiacomo' }, geometry: { type: 'Point', coordinates: [-122.442, 38.240] } }
      ]
    };

    // =========================
    // Helpers
    // =========================
    function announceCount(listTarget, n){
      listTarget.textContent = `${n} vineyard${n===1?'':'s'}`;
    }
    function featureId(f){
      const p = f.properties || {};
      return p.id || (p.Name || 'unknown');
    }
    function toPointFromPolygon(poly){
      const center = turf.center(poly).geometry.coordinates;
      const p = poly.properties || {};
      return {
        type:'Feature',
        properties: {
          id: featureId(poly),
          Name: p.Name || p.name || 'Unknown vineyard',
          SubAVA: p.SubAVA || p.AVA || '',
          Facts: p.Facts || p.facts || '',
          URL: p.URL || p.url || ''
        },
        geometry: { type:'Point', coordinates: center }
      };
    }
    function flyTo(lngLat, zoom=12.5){
      if (prefersReduced) {
        map.easeTo({ center: lngLat, zoom, duration: 0 });
      } else {
        map.flyTo({ center: lngLat, zoom, speed: 0.8, curve: 1.6, essential: true });
      }
    }
    function showPopupFor(f){
      const p = f.properties || {};
      const [lng,lat] = f.geometry.coordinates;
      const gm = `https://www.google.com/maps?q=${lat},${lng}`;
      const html = `
        <div>
          <div style="font-weight:700; margin-bottom:4px;">${p.Name || 'Vineyard'}</div>
          ${p.SubAVA ? `<div style="font-size:12px; opacity:.8;">${p.SubAVA}</div>` : ''}
          ${p.Facts ? `<div style="margin-top:6px;">${p.Facts}</div>` : ''}
          <div style="margin-top:8px; display:flex; gap:10px; flex-wrap:wrap">
            ${p.URL ? `<a class="btn" href="${p.URL}" target="_blank" rel="noopener">Learn more →</a>` : ''}
            <a class="btn secondary" href="${gm}" target="_blank" rel="noopener">Open in Maps</a>
          </div>
        </div>`;
      popup.setLngLat([lng,lat]).setHTML(html).addTo(map);
    }
    function selectFeature(id, {updateHash=true}={}){
      const f = (allPoints || []).find(ft => featureId(ft) === id) || (filteredPoints || []).find(ft => featureId(ft) === id);
      if (!f) return;
      const [lng,lat] = f.geometry.coordinates;
      flyTo([lng,lat]);
      showPopupFor(f);
      highlightInLists(id);
      if (updateHash) {
        history.replaceState(null, '', `#id=${encodeURIComponent(id)}`);
      }
    }
    function highlightInLists(id){
      for (const el of document.querySelectorAll('.item')) {
        el.classList.toggle('active', el.dataset.id === id);
      }
      const active = document.querySelector('.item.active');
      if (active) active.scrollIntoView({block:'nearest', behavior:'smooth'});
    }
    function fitAll(){
      const feats = (filteredPoints.length ? filteredPoints : allPoints);
      if (!feats.length) return;
      const b = feats.reduce((bounds, ft) => bounds.extend(ft.geometry.coordinates),
        new mapboxgl.LngLatBounds(feats[0].geometry.coordinates, feats[0].geometry.coordinates));
      map.fitBounds(b, { padding: {top:50,right:50,bottom:50,left:50} });
    }
    function buildLists(items){
      const mkItem = (f) => {
        const p = f.properties;
        const li = document.createElement('button');
        li.className = 'item';
        li.type = 'button';
        li.setAttribute('role','listitem');
        const id = featureId(f);
        li.dataset.id = id;
        li.innerHTML = `
          <div class="name">${p.Name}</div>
          <div class="meta">${p.SubAVA || ''}</div>
          <div class="actions">
            <span class="btn" aria-hidden="true">Fly to</span>
            ${p.URL ? `<a class="btn" href="${p.URL}" target="_blank" rel="noopener" onclick="event.stopPropagation()">Learn more</a>` : ''}
          </div>
        `;
        li.addEventListener('click', () => selectFeature(id));
        return li;
      };
      // Desktop list
      listEl.innerHTML = '';
      items.forEach(f => listEl.appendChild(mkItem(f)));
      announceCount(countEl, items.length);
      // Mobile list
      mListEl.innerHTML = '';
      items.forEach(f => mListEl.appendChild(mkItem(f)));
      announceCount(mCountEl, items.length);
    }
    function debounce(fn, ms=200){
      let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
    }
    const doFilter = debounce((q) => {
      const term = q.trim().toLowerCase();
      filteredPoints = !term ? allPoints.slice() : allPoints.filter(f => {
        const p = f.properties;
        return [p.Name, p.SubAVA, p.Facts].some(v => (v||'').toLowerCase().includes(term));
      });
      buildLists(filteredPoints);
      // Update map point source to filtered features
      if (map.getSource('vineyard-points')) {
        map.getSource('vineyard-points').setData({ type:'FeatureCollection', features: filteredPoints });
      }
    }, 160);

    // =========================
    // Sources & Layers
    // =========================
    map.on('load', async () => {
      // Option A: Vector polygons -> derive centroids for points
      
      if (CONFIG.vector.url && CONFIG.vector.sourceLayer) {
        map.addSource('vineyard-polygons', { type:'vector', url: CONFIG.vector.url });
        map.addLayer({ id:'vineyard-fill', type:'fill', source:'vineyard-polygons', 'source-layer': CONFIG.vector.sourceLayer, paint:{ 'fill-color':'#c8a96a', 'fill-opacity':0.35 } });
        map.addLayer({ id:'vineyard-outline', type:'line', source:'vineyard-polygons', 'source-layer': CONFIG.vector.sourceLayer, paint:{ 'line-color':'#c8a96a', 'line-width': 1.2 } });

        // Load a broad view to ensure tiles get cached, then harvest features from the source.
        await preloadTilesAndBuildCentroids();
      }
 else if (typeof CONFIG.pointsGeoJSON === 'string') {
        try {
          const res = await fetch(CONFIG.pointsGeoJSON, { cache: 'no-store' });
          const data = await res.json();
          await addPointSourceAndLayers(data);
        } catch (e) {
          console.warn('Failed to fetch points GeoJSON. Falling back to demo.', e);
          await addPointSourceAndLayers(demo);
        }
      }
      // Fallback demo
      else {
        await addPointSourceAndLayers(demo);
      }

      // Polygon click also selects
      if (map.getLayer('vineyard-fill')) {
        map.on('click', 'vineyard-fill', (e) => {
          const f = e.features && e.features[0];
          if (!f) return;
          selectFeature(featureId(f));
        });
        map.on('mouseenter', 'vineyard-fill', () => map.getCanvas().style.cursor = 'pointer');
        map.on('mouseleave', 'vineyard-fill', () => map.getCanvas().style.cursor = '');
      }

      // Deep link: #id=...
      const m = location.hash.match(/id=([^&]+)/);
      if (m) {
        const id = decodeURIComponent(m[1]);
        // allow sources to finish
        setTimeout(() => selectFeature(id, {updateHash:false}), 300);
      } else {
        fitAll();
      }
    });

    async function addPointSourceAndLayers(geojson){
      // Normalize properties so UI is consistent
      geojson.features.forEach(f => {
        const p = f.properties || {};
        f.properties = {
          id: featureId(f),
          Name: p.Name || p.name || 'Unknown vineyard',
          SubAVA: p.SubAVA || p.AVA || '',
          Facts: p.Facts || p.facts || '',
          URL: p.URL || p.url || ''
        };
      });
      allPoints = geojson.features.slice();
      filteredPoints = allPoints.slice();
      buildLists(filteredPoints);

      // Clustered source (great for many vineyards)
      map.addSource('vineyard-points', {
        type: 'geojson',
        data: { type:'FeatureCollection', features: filteredPoints },
        cluster: true,
        clusterRadius: 50,
        clusterMaxZoom: 14
      });

      // Clusters
      map.addLayer({
        id: 'clusters',
        type: 'circle',
        source: 'vineyard-points',
        filter: ['has', 'point_count'],
        paint: {
          'circle-color': [
            'step', ['get', 'point_count'],
            '#42506B', 5, '#5e6e90', 15, '#7f8dae'
          ],
          'circle-radius': [
            'step', ['get', 'point_count'],
            12, 5, 16, 15, 20
          ],
          'circle-stroke-color': '#0b0c10',
          'circle-stroke-width': 1.2
        }
      });
      map.addLayer({
        id: 'cluster-count',
        type: 'symbol',
        source: 'vineyard-points',
        filter: ['has', 'point_count'],
        layout: { 'text-field': ['get','point_count_abbreviated'], 'text-size': 12 },
        paint: { 'text-color': '#eef2f7' }
      });

      // Unclustered points
      map.addLayer({
        id: 'vineyard-circles',
        type: 'circle',
        source: 'vineyard-points',
        filter: ['!', ['has', 'point_count']],
        paint: {
          'circle-radius': ['interpolate', ['linear'], ['zoom'], 5, 4, 10, 7, 14, 9],
          'circle-color': '#c8a96a',
          'circle-stroke-color': '#0b0c10',
          'circle-stroke-width': 1.2
        }
      });
      map.addLayer({
        id: 'vineyard-labels',
        type: 'symbol',
        source: 'vineyard-points',
        filter: ['!', ['has', 'point_count']],
        layout: {
          'text-field': ['get', 'Name'],
          'text-size': 12,
          'text-offset': [0, 1.1],
          'text-anchor': 'top'
        },
        paint: {
          'text-color': '#eef2f7',
          'text-halo-color': '#0b0c10',
          'text-halo-width': 1.2
        }
      });

      // Interactivity
      map.on('click', 'clusters', function (e) {
        const features = map.queryRenderedFeatures(e.point, { layers: ['clusters'] });
        const clusterId = features[0].properties.cluster_id;
        map.getSource('vineyard-points').getClusterExpansionZoom(clusterId, function (err, zoom) {
          if (err) return;
          map.easeTo({ center: features[0].geometry.coordinates, zoom });
        });
      });
      map.on('click', 'vineyard-circles', (e) => {
        const f = e.features && e.features[0];
        if (!f) return;
        selectFeature(featureId(f));
      });
      ['clusters','vineyard-circles'].forEach(l => {
        map.on('mouseenter', l, () => map.getCanvas().style.cursor = 'pointer');
        map.on('mouseleave', l, () => map.getCanvas().style.cursor = '');
      });
    }

    
    async function preloadTilesAndBuildCentroids(){
      // Save current view
      const prev = { center: map.getCenter(), zoom: map.getZoom(), bearing: map.getBearing(), pitch: map.getPitch() };

      // Zoom out to load a wider swath of tiles around the default center
      map.easeTo({ center: CONFIG.defaultCenter, zoom: Math.min(9, prev.zoom), duration: 0 });
      await map.once('idle');

      // Harvest centroids from vector source tiles
      const centroidFC = harvestVectorCentroids();
      if (centroidFC.features.length === 0) {
        console.warn('No vector features found. Double-check the source-layer name.');
      }
      await addPointSourceAndLayers(centroidFC.features.length ? centroidFC : demo);

      // Restore previous view
      map.easeTo({ center: prev.center, zoom: prev.zoom, bearing: prev.bearing, pitch: prev.pitch, duration: 0 });
    }

    function harvestVectorCentroids(){
      const feats = map.querySourceFeatures('vineyard-polygons', { sourceLayer: CONFIG.vector.sourceLayer }) || [];
      const uniq = new Map();
      for (const f of feats) {
        const id = featureId(f);
        if (!uniq.has(id)) {
          uniq.set(id, toPointFromPolygon(f));
        }
      }
      return { type: 'FeatureCollection', features: Array.from(uniq.values()) };
    }

    // =========================
    // UI wiring
    // =========================
    fitAllBtn.addEventListener('click', fitAll);
    mFitAllBtn.addEventListener('click', fitAll);
    document.getElementById('refresh').addEventListener('click', preloadTilesAndBuildCentroids);
    filterEl.addEventListener('input', (e)=> doFilter(e.target.value));
    mFilterEl.addEventListener('input', (e)=> doFilter(e.target.value));

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.key === '/' && document.activeElement !== filterEl && document.activeElement !== mFilterEl) {
        e.preventDefault();
        (window.innerWidth <= 900 ? mFilterEl : filterEl).focus();
      } else if (e.key.toLowerCase() === 'f') {
        fitAll();
      } else if (e.key.toLowerCase() === 's' && window.innerWidth > 900) {
        setCollapsed(!collapsed);
      } else if (e.key === 'Escape') {
        popup.remove();
        history.replaceState(null, '', location.pathname);
        const active = document.querySelector('.item.active'); if (active) active.classList.remove('active');
      }
    });

    // Sidebar collapse (desktop)
    const appEl = document.querySelector('.app');
    let collapsed = false;
    const fab = document.getElementById('sidebar-fab');
    const expandBtn = document.getElementById('expand-sidebar');
    collapseBtn.setAttribute('aria-expanded','true');
    function setCollapsed(val){
      collapsed = !!val;
      appEl.classList.toggle('sidebar-collapsed', collapsed);
      document.getElementById('sidebar').setAttribute('aria-hidden', collapsed ? 'true' : 'false');
      collapseBtn.textContent = collapsed ? 'Expand' : 'Collapse';
      collapseBtn.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
      // Show floating reopen button only when collapsed and on desktop widths
      if (collapsed && window.innerWidth > 900) { fab.style.display = 'block'; } else { fab.style.display = 'none'; }
      setTimeout(() => map.resize(), 60);
    }
    collapseBtn.addEventListener('click', () => setCollapsed(!collapsed));
    expandBtn.addEventListener('click', () => setCollapsed(false));
    window.addEventListener('resize', () => { if (window.innerWidth <= 900) fab.style.display = 'none'; else if (collapsed) fab.style.display = 'block'; });

    // Drawer controls (mobile)
    function setDrawerOpen(open) {
      drawerEl.classList.toggle('open', open);
      drawerButton.setAttribute('aria-expanded', open ? 'true' : 'false');
    }
    drawerButton.addEventListener('click', () => {
      const open = !drawerEl.classList.contains('open');
      setDrawerOpen(open);
      if (open) mFilterEl.focus();
    });
    document.getElementById('drawer-handle').addEventListener('click', () => setDrawerOpen(!drawerEl.classList.contains('open')));

    // Clicking map on mobile closes the drawer
    map.on('click', () => { if (window.innerWidth <= 900) setDrawerOpen(false); });

  </script>
</body>
</html>
    .drawer {
      position: fixed; left: 0; right: 0; bottom: 0;
      height: 56px; /* closed height */
      background: var(--panel);
      border-top:1px solid var(--border);
      box-shadow: 0 -12px 30px rgba(0,0,0,.35);
      border-top-left-radius: 16px; border-top-right-radius: 16px;
      transform: translateY(100%);
      transition: transform .28s ease;
      z-index: 2;
      display:flex; flex-direction:column;
    }
    .drawer.open { transform: translateY(0); }
    .drawer .handle {
      display:flex; justify-content:center; padding: 8px; cursor:pointer;
    }
    .drawer .handle .pill {
      width: 48px; height: 5px; border-radius:99px; background:#273049;
    }
    .drawer .content {
      padding: 8px 12px 12px 12px;
      overflow:auto; flex:1; min-height: 40vh; max-height: 70vh;
    }
    .drawer .header { display:flex; align-items:center; justify-content:space-between; gap:10px; padding:0 4px 8px 4px; }
    .drawer .search { margin: 6px 0 10px; }
    .drawer .list { padding-bottom: max(10px, var(--safe-bottom)); }
    .hide-on-mobile { display: block; }
    .show-on-mobile { display: none; }
    /* Map popup */
    .mapboxgl-popup { font: 14px/1.25 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    .mapboxgl-popup-content { border-radius: 12px; padding: 10px 12px; background:#0f1219; color: var(--text); border:1px solid #273049; text-align:left; }
    .mapboxgl-popup-close-button { color: var(--text); }

    /* Tablet/desktop: sidebar + map */
    @media (max-width: 900px) {
      .app { grid-template-columns: 1fr; }
      .sidebar { display:none; }
      .hide-on-mobile { display:none; }
      .show-on-mobile { display:block; }
    }
  </style>
</head>
<body>
  <div class="app">
    <aside class="sidebar" aria-label="Vineyard navigation" id="sidebar">
      <div class="brand">
        <h1>Vineyard Sources</h1>
        <div class="controls">
          <button id="fit-all" class="btn" title="Zoom to all vineyards">Fit all</button>
          <button id="collapse" class="btn secondary" title="Hide/show sidebar">Collapse</button>
        </div>
      </div>
      <div class="search">
        <input id="filter" type="search" placeholder="Filter vineyards… (name, AVA, notes)" aria-label="Filter vineyards" />
      </div>
      <div class="count" id="count" aria-live="polite">—</div>
      <div class="list" id="list" role="list"></div>
    </aside>

    <div id="map" role="region" aria-label="Map of vineyard locations"></div>

    <!-- Mobile drawer -->
    <div class="drawer-toggle show-on-mobile">
      <button class="drawer-button" id="drawer-button" aria-expanded="false" aria-controls="mobile-drawer">Vineyards</button>
    </div>
    <section class="drawer" id="mobile-drawer" aria-label="Vineyard list drawer">
      <div class="handle" id="drawer-handle" aria-hidden="true"><div class="pill"></div></div>
      <div class="content">
        <div class="header">
          <div class="count" id="m-count">—</div>
          <div class="controls"><button id="m-fit-all" class="btn">Fit all</button></div>
        </div>
        <div class="search"><input id="m-filter" type="search" placeholder="Search vineyards…" aria-label="Search vineyards" /></div>
        <div class="list" id="m-list" role="list"></div>
      </div>
    </section>
  </div>

  <script>
    // =========================
    // Configuration
    // =========================
    const CONFIG = {
      accessToken: 'pk.eyJ1IjoiZ3JhaGFtLWJjZWxsYXJzIiwiYSI6ImNsbmR1dWZiZjA3OXoyeWxpNTR4Z29wMjMifQ.Dw9ZRaGWdJkYUrFpML7XTw', // TODO: replace
      styleUrl: 'mapbox://styles/graham-bcellars/clogch2tt004201oi8i3jgyjy', // TODO: replace
      // Option A: polygon vector tileset for vineyard boundaries (set both or leave sourceLayer empty to skip)
      vector: { url: 'mapbox://graham-bcellars.clnunbjdd0gcp2nn54qh84xr9-79q6y', sourceLayer: 'vineyard-map' }, // TODO: set source-layer or leave '' to skip
      // Option B: points GeoJSON (recommended if you don't have a polygon tileset)
      pointsGeoJSON: null, // Or set to a URL string like '/data/vineyards_points.geojson'
      // UI
      defaultCenter: [-122.37, 38.45],
      defaultZoom: 10
    };

    // =========================
    // Map init
    // =========================
    mapboxgl.accessToken = CONFIG.accessToken;
    const map = new mapboxgl.Map({
      container: 'map',
      style: CONFIG.styleUrl,
      center: CONFIG.defaultCenter,
      zoom: CONFIG.defaultZoom,
      cooperativeGestures: true,
      attributionControl: true,
      pitch: 0,
      maxPitch: 80
    });
    map.addControl(new mapboxgl.NavigationControl({showCompass: true}), 'top-right');
    map.addControl(new mapboxgl.FullscreenControl(), 'top-right');
    map.addControl(new mapboxgl.GeolocateControl({ positionOptions: { enableHighAccuracy: true }, trackUserLocation: false }), 'top-right');

    // =========================
    // State
    // =========================
    const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const listEl = document.getElementById('list');
    const countEl = document.getElementById('count');
    const filterEl = document.getElementById('filter');
    const mListEl = document.getElementById('m-list');
    const mCountEl = document.getElementById('m-count');
    const mFilterEl = document.getElementById('m-filter');
    const drawerButton = document.getElementById('drawer-button');
    const drawerEl = document.getElementById('mobile-drawer');
    const fitAllBtn = document.getElementById('fit-all');
    const mFitAllBtn = document.getElementById('m-fit-all');
    const collapseBtn = document.getElementById('collapse');
    let allPoints = [];         // Array<Feature<Point>>
    let filteredPoints = [];    // Array<Feature<Point>>
    const popup = new mapboxgl.Popup({ closeButton: true, closeOnClick: true });

    // Demo fallback data if you haven't wired in a tileset/geojson yet
    const demo = {
      type: 'FeatureCollection',
      features: [
        { type: 'Feature', properties: { id: 'to-kalon', Name: 'To Kalon Vineyard', SubAVA: 'Oakville AVA, Napa Valley', Facts: 'Historic site; well-drained alluvial fans; Cabernet Sauvignon', URL: 'https://example.com/to-kalon' }, geometry: { type: 'Point', coordinates: [-122.4139, 38.4387] } },
        { type: 'Feature', properties: { id: 'stagecoach', Name: 'Stagecoach Vineyard', SubAVA: 'Atlas Peak AVA, Napa Valley', Facts: 'Volcanic tuff/red soils; mountain fruit', URL: 'https://example.com/stagecoach' }, geometry: { type: 'Point', coordinates: [-122.239, 38.396] } },
        { type: 'Feature', properties: { id: 'sangiacomo', Name: 'Sangiacomo Vineyard', SubAVA: 'Carneros AVA, Sonoma', Facts: 'Cool-climate; Chardonnay & Pinot Noir', URL: 'https://example.com/sangiacomo' }, geometry: { type: 'Point', coordinates: [-122.442, 38.240] } }
      ]
    };

    // =========================
    // Helpers
    // =========================
    function announceCount(listTarget, n){
      listTarget.textContent = `${n} vineyard${n===1?'':'s'}`;
    }
    function featureId(f){
      const p = f.properties || {};
      return p.id || (p.Name || 'unknown');
    }
    function toPointFromPolygon(poly){
      const center = turf.center(poly).geometry.coordinates;
      const p = poly.properties || {};
      return {
        type:'Feature',
        properties: {
          id: featureId(poly),
          Name: p.Name || p.name || 'Unknown vineyard',
          SubAVA: p.SubAVA || p.AVA || '',
          Facts: p.Facts || p.facts || '',
          URL: p.URL || p.url || ''
        },
        geometry: { type:'Point', coordinates: center }
      };
    }
    function flyTo(lngLat, zoom=12.5){
      if (prefersReduced) {
        map.easeTo({ center: lngLat, zoom, duration: 0 });
      } else {
        map.flyTo({ center: lngLat, zoom, speed: 0.8, curve: 1.6, essential: true });
      }
    }
    function showPopupFor(f){
      const p = f.properties || {};
      const [lng,lat] = f.geometry.coordinates;
      const gm = `https://www.google.com/maps?q=${lat},${lng}`;
      const html = `
        <div>
          <div style="font-weight:700; margin-bottom:4px;">${p.Name || 'Vineyard'}</div>
          ${p.SubAVA ? `<div style="font-size:12px; opacity:.8;">${p.SubAVA}</div>` : ''}
          ${p.Facts ? `<div style="margin-top:6px;">${p.Facts}</div>` : ''}
          <div style="margin-top:8px; display:flex; gap:10px; flex-wrap:wrap">
            ${p.URL ? `<a class="btn" href="${p.URL}" target="_blank" rel="noopener">Learn more →</a>` : ''}
            <a class="btn secondary" href="${gm}" target="_blank" rel="noopener">Open in Maps</a>
          </div>
        </div>`;
      popup.setLngLat([lng,lat]).setHTML(html).addTo(map);
    }
    function selectFeature(id, {updateHash=true}={}){
      const f = (allPoints || []).find(ft => featureId(ft) === id) || (filteredPoints || []).find(ft => featureId(ft) === id);
      if (!f) return;
      const [lng,lat] = f.geometry.coordinates;
      flyTo([lng,lat]);
      showPopupFor(f);
      highlightInLists(id);
      if (updateHash) {
        history.replaceState(null, '', `#id=${encodeURIComponent(id)}`);
      }
    }
    function highlightInLists(id){
      for (const el of document.querySelectorAll('.item')) {
        el.classList.toggle('active', el.dataset.id === id);
      }
      const active = document.querySelector('.item.active');
      if (active) active.scrollIntoView({block:'nearest', behavior:'smooth'});
    }
    function fitAll(){
      const feats = (filteredPoints.length ? filteredPoints : allPoints);
      if (!feats.length) return;
      const b = feats.reduce((bounds, ft) => bounds.extend(ft.geometry.coordinates),
        new mapboxgl.LngLatBounds(feats[0].geometry.coordinates, feats[0].geometry.coordinates));
      map.fitBounds(b, { padding: {top:50,right:50,bottom:50,left:50} });
    }
    function buildLists(items){
      const mkItem = (f) => {
        const p = f.properties;
        const li = document.createElement('button');
        li.className = 'item';
        li.type = 'button';
        li.setAttribute('role','listitem');
        const id = featureId(f);
        li.dataset.id = id;
        li.innerHTML = `
          <div class="name">${p.Name}</div>
          <div class="meta">${p.SubAVA || ''}</div>
          <div class="actions">
            <span class="btn" aria-hidden="true">Fly to</span>
            ${p.URL ? `<a class="btn" href="${p.URL}" target="_blank" rel="noopener" onclick="event.stopPropagation()">Learn more</a>` : ''}
          </div>
        `;
        li.addEventListener('click', () => selectFeature(id));
        return li;
      };
      // Desktop list
      listEl.innerHTML = '';
      items.forEach(f => listEl.appendChild(mkItem(f)));
      announceCount(countEl, items.length);
      // Mobile list
      mListEl.innerHTML = '';
      items.forEach(f => mListEl.appendChild(mkItem(f)));
      announceCount(mCountEl, items.length);
    }
    function debounce(fn, ms=200){
      let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
    }
    const doFilter = debounce((q) => {
      const term = q.trim().toLowerCase();
      filteredPoints = !term ? allPoints.slice() : allPoints.filter(f => {
        const p = f.properties;
        return [p.Name, p.SubAVA, p.Facts].some(v => (v||'').toLowerCase().includes(term));
      });
      buildLists(filteredPoints);
      // Update map point source to filtered features
      if (map.getSource('vineyard-points')) {
        map.getSource('vineyard-points').setData({ type:'FeatureCollection', features: filteredPoints });
      }
    }, 160);

    // =========================
    // Sources & Layers
    // =========================
    map.on('load', async () => {
      // Option A: Vector polygons -> derive centroids for points
      if (CONFIG.vector.url && CONFIG.vector.sourceLayer) {
        map.addSource('vineyard-polygons', { type:'vector', url: CONFIG.vector.url });
        map.addLayer({ id:'vineyard-fill', type:'fill', source:'vineyard-polygons', 'source-layer': CONFIG.vector.sourceLayer, paint:{ 'fill-color':'#c8a96a', 'fill-opacity':0.35 } });
        map.addLayer({ id:'vineyard-outline', type:'line', source:'vineyard-polygons', 'source-layer': CONFIG.vector.sourceLayer, paint:{ 'line-color':'#c8a96a', 'line-width': 1.2 } });

        // Try to collect centroids for currently available features
        await map.once('idle');
        const polys = map.queryRenderedFeatures({ layers:['vineyard-fill'] }) || [];
        const uniques = new Map();
        polys.forEach(f => {
          const p = f.properties || {};
          const id = featureId(f);
          if (!uniques.has(id)) uniques.set(id, toPointFromPolygon(f));
        });
        const centroidFC = { type:'FeatureCollection', features: Array.from(uniques.values()) };
        await addPointSourceAndLayers(centroidFC);
      }
      // Option B: external points GeoJSON
      else if (typeof CONFIG.pointsGeoJSON === 'string') {
        try {
          const res = await fetch(CONFIG.pointsGeoJSON, { cache: 'no-store' });
          const data = await res.json();
          await addPointSourceAndLayers(data);
        } catch (e) {
          console.warn('Failed to fetch points GeoJSON. Falling back to demo.', e);
          await addPointSourceAndLayers(demo);
        }
      }
      // Fallback demo
      else {
        await addPointSourceAndLayers(demo);
      }

      // Polygon click also selects
      if (map.getLayer('vineyard-fill')) {
        map.on('click', 'vineyard-fill', (e) => {
          const f = e.features && e.features[0];
          if (!f) return;
          selectFeature(featureId(f));
        });
        map.on('mouseenter', 'vineyard-fill', () => map.getCanvas().style.cursor = 'pointer');
        map.on('mouseleave', 'vineyard-fill', () => map.getCanvas().style.cursor = '');
      }

      // Deep link: #id=...
      const m = location.hash.match(/id=([^&]+)/);
      if (m) {
        const id = decodeURIComponent(m[1]);
        // allow sources to finish
        setTimeout(() => selectFeature(id, {updateHash:false}), 300);
      } else {
        fitAll();
      }
    });

    async function addPointSourceAndLayers(geojson){
      // Normalize properties so UI is consistent
      geojson.features.forEach(f => {
        const p = f.properties || {};
        f.properties = {
          id: featureId(f),
          Name: p.Name || p.name || 'Unknown vineyard',
          SubAVA: p.SubAVA || p.AVA || '',
          Facts: p.Facts || p.facts || '',
          URL: p.URL || p.url || ''
        };
      });
      allPoints = geojson.features.slice();
      filteredPoints = allPoints.slice();
      buildLists(filteredPoints);

      // Clustered source (great for many vineyards)
      map.addSource('vineyard-points', {
        type: 'geojson',
        data: { type:'FeatureCollection', features: filteredPoints },
        cluster: true,
        clusterRadius: 50,
        clusterMaxZoom: 14
      });

      // Clusters
      map.addLayer({
        id: 'clusters',
        type: 'circle',
        source: 'vineyard-points',
        filter: ['has', 'point_count'],
        paint: {
          'circle-color': [
            'step', ['get', 'point_count'],
            '#42506B', 5, '#5e6e90', 15, '#7f8dae'
          ],
          'circle-radius': [
            'step', ['get', 'point_count'],
            12, 5, 16, 15, 20
          ],
          'circle-stroke-color': '#0b0c10',
          'circle-stroke-width': 1.2
        }
      });
      map.addLayer({
        id: 'cluster-count',
        type: 'symbol',
        source: 'vineyard-points',
        filter: ['has', 'point_count'],
        layout: { 'text-field': ['get','point_count_abbreviated'], 'text-size': 12 },
        paint: { 'text-color': '#eef2f7' }
      });

      // Unclustered points
      map.addLayer({
        id: 'vineyard-circles',
        type: 'circle',
        source: 'vineyard-points',
        filter: ['!', ['has', 'point_count']],
        paint: {
          'circle-radius': ['interpolate', ['linear'], ['zoom'], 5, 4, 10, 7, 14, 9],
          'circle-color': '#c8a96a',
          'circle-stroke-color': '#0b0c10',
          'circle-stroke-width': 1.2
        }
      });
      map.addLayer({
        id: 'vineyard-labels',
        type: 'symbol',
        source: 'vineyard-points',
        filter: ['!', ['has', 'point_count']],
        layout: {
          'text-field': ['get', 'Name'],
          'text-size': 12,
          'text-offset': [0, 1.1],
          'text-anchor': 'top'
        },
        paint: {
          'text-color': '#eef2f7',
          'text-halo-color': '#0b0c10',
          'text-halo-width': 1.2
        }
      });

      // Interactivity
      map.on('click', 'clusters', function (e) {
        const features = map.queryRenderedFeatures(e.point, { layers: ['clusters'] });
        const clusterId = features[0].properties.cluster_id;
        map.getSource('vineyard-points').getClusterExpansionZoom(clusterId, function (err, zoom) {
          if (err) return;
          map.easeTo({ center: features[0].geometry.coordinates, zoom });
        });
      });
      map.on('click', 'vineyard-circles', (e) => {
        const f = e.features && e.features[0];
        if (!f) return;
        selectFeature(featureId(f));
      });
      ['clusters','vineyard-circles'].forEach(l => {
        map.on('mouseenter', l, () => map.getCanvas().style.cursor = 'pointer');
        map.on('mouseleave', l, () => map.getCanvas().style.cursor = '');
      });
    }

    // =========================
    // UI wiring
    // =========================
    fitAllBtn.addEventListener('click', fitAll);
    mFitAllBtn.addEventListener('click', fitAll);
    filterEl.addEventListener('input', (e)=> doFilter(e.target.value));
    mFilterEl.addEventListener('input', (e)=> doFilter(e.target.value));

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.key === '/' && document.activeElement !== filterEl && document.activeElement !== mFilterEl) {
        e.preventDefault();
        (window.innerWidth <= 900 ? mFilterEl : filterEl).focus();
      } else if (e.key.toLowerCase() === 'f') {
        fitAll();
      } else if (e.key === 'Escape') {
        popup.remove();
        history.replaceState(null, '', location.pathname);
        const active = document.querySelector('.item.active'); if (active) active.classList.remove('active');
      }
    });

    // Sidebar collapse (desktop)
    let collapsed = false;
    collapseBtn.addEventListener('click', () => {
      const sidebar = document.getElementById('sidebar');
      collapsed = !collapsed;
      sidebar.style.display = collapsed ? 'none' : 'flex';
      collapseBtn.textContent = collapsed ? 'Expand' : 'Collapse';
      // When collapsed on desktop, map goes full width automatically via grid
    });

    // Drawer controls (mobile)
    function setDrawerOpen(open) {
      drawerEl.classList.toggle('open', open);
      drawerButton.setAttribute('aria-expanded', open ? 'true' : 'false');
    }
    drawerButton.addEventListener('click', () => {
      const open = !drawerEl.classList.contains('open');
      setDrawerOpen(open);
      if (open) mFilterEl.focus();
    });
    document.getElementById('drawer-handle').addEventListener('click', () => setDrawerOpen(!drawerEl.classList.contains('open')));

    // Clicking map on mobile closes the drawer
    map.on('click', () => { if (window.innerWidth <= 900) setDrawerOpen(false); });

  </script>
</body>
</html>
        'fill-opacity': 0.8
    }
});
        map.on('click', 'vineyard-map', function (e) {
            map.getCanvas().style.cursor = 'pointer';  
            var coordinates = e.features[0].geometry.coordinates.slice();
            var name = e.features[0].properties.Name;
            var subava = e.features[0].properties.SubAVA;
            
            new mapboxgl.Popup()
            .setLngLat(e.lngLat)
            .setHTML('<h3 class="popup-name">' + name + '</h3><br><p>AMERICAN VITICULTURAL AREA</p><hr style="width: 66%"><p class="popup-subava">' + subava + '</p>') // Replace 'description' with the property you want to display
           .addTo(map);  
}); 

    });
    



    </script>  
  </body>  
</html>
